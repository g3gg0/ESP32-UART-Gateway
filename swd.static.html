<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SWD Debug Console</title>
    
    <script>
/* ============= EspSerial Class ============= */
class EspSerial {
    constructor() {
        this.port = null;
        this.reader = null;
        this.rxBuffer = new Uint8Array(0);
        this.inputDone = false;
        this.data_cbr = null; /* Raw UART-like bytes */
        this.config_cbr = null; /* Config packets */
        this.log_cbr = null; /* Parsed ESP log packets */
        this.disconnect_cbr = null; /* Port disconnect callback */
        this._disconnectHandler = null;
        this._disconnecting = false;

        /* SWD request/response tracking (new SWD sub-protocol) */
        this._swdSeq = 1;
        this._swdPending = new Map(); /* seq -> { resolve, reject, timer } */
        this._swdDefaultTimeoutMs = 1500;

        /* Extended mode activation magic: type 0x000A packet with 8-byte payload */
        this.EXTMODE_MAGIC = new Uint8Array([
            0x0C, 0x00,  /* length: 12 (4 bytes header + 8 bytes payload) */
            0x0A, 0x00,  /* type: 0x000A */
            0x55, 0x41, 0x52, 0x54,  /* U A R T */
            0x47, 0x57, 0x45, 0x58   /* G W E X */
        ]);
        this.EXTMODE_PACKET_SIZE = 12;

        /* Packet header constants */
        this.PACKET_HEADER_SIZE = 4;  /* uint16_t length + uint16_t type */
        this.PACKET_TYPE_DATA = 0x00;
        this.PACKET_TYPE_CONFIG = 0x01;
        this.PACKET_TYPE_CONTROL = 0x02;
        this.PACKET_TYPE_LOG = 0x03;
        this.UART_PACKET_TYPE_SWD = 0x04;

        this.CTRL_CMD_SIZE = 16;
        this.LOGMSG_MAX_LEN = 256;

        this.extendedMode = false;

        /* Log message waiting mechanism */
        this.nextLogPromise = null;
        this.nextLogResolve = null;
        this.nextLogTimer = null;
    }

    setDataCallback(callback) {
        this.data_cbr = callback;
    }

    setConfigCallback(callback) {
        this.config_cbr = callback;
    }

    setLogCallback(callback) {
        this.log_cbr = callback;
    }

    setDisconnectCallback(callback) {
        this.disconnect_cbr = callback;
    }

    consoleLogHex(prefix, data) {
        if (!data) return;
        const bytes = data instanceof Uint8Array ? data : new Uint8Array(data);
        console.log(`${prefix} [${bytes.length} bytes]`);
    }

    async flushSerialData(durationMs) {
        if (!this.port) return;
        try {
            const reader = this.port.readable.getReader();
            const startTime = Date.now();
            let bytesDiscarded = 0;

            while (Date.now() - startTime < durationMs) {
                try {
                    const { value, done } = await Promise.race([
                        reader.read(),
                        new Promise((_, reject) =>
                            setTimeout(() => reject(new Error('flush timeout')), 50)
                        )
                    ]);

                    if (done) break;
                    if (value) {
                        bytesDiscarded += value.length;
                    }
                } catch (err) {
                    /* Timeout waiting for data, continue flushing */
                    if (err.message !== 'flush timeout') throw err;
                }
            }

            reader.releaseLock();
            logToConsole(`Serial flush complete: ${bytesDiscarded} bytes discarded`, 'info');
        } catch (err) {
            logToConsole(`Serial flush error: ${err.message}`, 'info');
        }
    }

    async connect() {
        try {
            this.port = await navigator.serial.requestPort();
            await this.port.open({ baudRate: 921600 });

            if (!this._disconnectHandler) {
                this._disconnectHandler = (event) => {
                    if (event && event.port === this.port) {
                        this.handlePortDisconnect('system');
                    }
                };
            }
            navigator.serial.addEventListener('disconnect', this._disconnectHandler);

            /* Ensure RTS and DTR are low after opening */
            try {
                await this.port.setSignals({ requestToSend: false, dataTerminalReady: false });
            } catch (e) {
                logToConsole(`Warning: Failed to set RTS/DTR: ${e.message}`, 'info');
            }

            /* Flush any pending serial data for 250ms */
            await this.flushSerialData(250);

            /* Start reader task (non-blocking) */
            this.readFromPort();

            await new Promise(resolve => setTimeout(resolve, 500));
            logToConsole('ESP Serial: Connected', 'info');

            /* Send extended mode activation magic */
            const magic = this.buildExtModeActivationPacket();
            await this.sendPacket(magic, 'ExtMode Magic');
            
            logToConsole('ESP Serial: Extended mode activation sent', 'info');
            this.extendedMode = true;

            /* Wait for first log message to confirm extended mode is working */
            logToConsole('ESP Serial: Waiting for log message...', 'info');
            const logMsg = await this.waitForLogMessage(2000);
            if (!logMsg) {
                throw new Error('No log message received after extended mode activation - device may not be responding');
            }
            logToConsole(`ESP Serial: Confirmed with log: "${logMsg.substring(0, 50)}..."`, 'info');

            /* Request current configuration - MUST succeed */
            await new Promise(resolve => setTimeout(resolve, 100));
            logToConsole('Requesting device configuration...', 'info');
            await this.requestConfig();
            logToConsole('Device configuration received', 'info');

            return true;
        } catch (err) {
            if (err.name !== 'NotFoundError') {
                logToConsole(`ESP Serial: Connection error: ${err.message}`, 'info');
            }
            return false;
        }
    }

    async waitForLogMessage(timeoutMs = 2000) {
        return new Promise((resolve) => {
            this.nextLogResolve = resolve;
            this.nextLogTimer = setTimeout(() => {
                this.nextLogResolve = null;
                resolve(null);
            }, timeoutMs);
        });
    }

    async disconnect() {
        try {
            this._disconnecting = true;
            this.inputDone = true;

            /* Release reader lock if it exists */
            if (this.reader) {
                try {
                    this.reader.cancel();
                } catch (e) {
                    /* Reader might already be released */
                }
                this.reader = null;
            }

            /* Wait a moment for read loop to exit */
            await new Promise(resolve => setTimeout(resolve, 50));

            if (this.port) {
                try {
                    await this.port.close();
                } catch (e) {
                    logToConsole(`Port close error: ${e.message}`, 'info');
                }
                this.port = null;
            }
            if (this._disconnectHandler) {
                navigator.serial.removeEventListener('disconnect', this._disconnectHandler);
            }
            this.notifyDisconnect({ reason: 'manual' });
            logToConsole('ESP Serial: Disconnected', 'info');
        } catch (err) {
            logToConsole(`ESP Serial: Disconnect error: ${err.message}`, 'info');
        } finally {
            this._disconnecting = false;
        }
    }

    notifyDisconnect(info) {
        this._rejectAllSwdPending(new Error('Disconnected'));
        if (this.disconnect_cbr) {
            try {
                this.disconnect_cbr(info);
            } catch (err) {
                logToConsole(`Disconnect callback error: ${err.message}`, 'info');
            }
        }
    }

    _rejectAllSwdPending(err) {
        if (!this._swdPending || this._swdPending.size === 0) return;
        for (const [seq, entry] of this._swdPending.entries()) {
            if (entry && entry.timer) {
                clearTimeout(entry.timer);
            }
            if (entry && entry.reject) {
                try {
                    entry.reject(err);
                } catch (e) {
                    /* ignore */
                }
            }
            this._swdPending.delete(seq);
        }
    }

    async handlePortDisconnect(reason) {
        if (this._disconnecting) return;
        this._disconnecting = true;

        this.inputDone = true;
        if (this.reader) {
            try {
                await this.reader.cancel();
            } catch (e) {
                /* ignore */
            }
            this.reader = null;
        }

        if (this.port) {
            try {
                await this.port.close();
            } catch (e) {
                /* ignore */
            }
            this.port = null;
        }

        if (this._disconnectHandler) {
            navigator.serial.removeEventListener('disconnect', this._disconnectHandler);
        }

        this.notifyDisconnect({ reason: reason || 'unknown' });
        logToConsole('ESP Serial: Port disconnected', 'info');
        this._disconnecting = false;
    }

    appendBuffer(a, b) {
        if (!a || a.length === 0) return new Uint8Array(b);
        const out = new Uint8Array(a.length + b.length);
        out.set(a, 0);
        out.set(b, a.length);
        return out;
    }

    buildExtModeActivationPacket() {
        /* Magic packet is already complete: header + payload */
        return new Uint8Array(this.EXTMODE_MAGIC);
    }

    buildPacketHeader(payloadLength, type) {
        /* Calculate total length: payload + 4-byte header */
        const length = payloadLength + 4;
        const header = new Uint8Array(this.PACKET_HEADER_SIZE);
        header[0] = length & 0xFF;          /* length low byte */
        header[1] = (length >> 8) & 0xFF;   /* length high byte */
        header[2] = type & 0xFF;            /* type low byte */
        header[3] = (type >> 8) & 0xFF;     /* type high byte */
        return header;
    }

    buildPacket(payload, type) {
        /* Build complete packet: header + payload */
        const header = this.buildPacketHeader(payload.length, type);
        return this.appendBuffer(header, payload);
    }

    buildControlPacket(command) {
        const cmdBytes = new TextEncoder().encode(command);
        const payload = new Uint8Array(this.CTRL_CMD_SIZE);
        for (let i = 0; i < Math.min(cmdBytes.length, this.CTRL_CMD_SIZE); i++) {
            payload[i] = cmdBytes[i];
        }
        return this.buildPacket(payload, this.PACKET_TYPE_CONTROL);
    }

    processEspPackets(data) {
        this.rxBuffer = this.appendBuffer(this.rxBuffer, data);

        const emitData = (chunk) => {
            if (!chunk || chunk.length === 0) return;
            if (this.data_cbr) {
                this.data_cbr(chunk);
            }
        };

        const emitConfig = (configBytes) => {
            let parsedConfig = {
                type: 'config_packet',
                data: configBytes,
                baud_rate: 0,
                tx_gpio: 0,
                rx_gpio: 0,
                reset_gpio: 0,
                control_gpio: 0,
                led_gpio: 0,
                extended_mode: 0
            };

            /* Parse config structure if exactly 12 bytes */
            if (configBytes.length === 12) {
                const view = new DataView(configBytes.buffer, configBytes.byteOffset, configBytes.length);
                parsedConfig.baud_rate = view.getUint32(0, true);
                parsedConfig.tx_gpio = configBytes[4];
                parsedConfig.rx_gpio = configBytes[5];
                parsedConfig.reset_gpio = configBytes[6];
                parsedConfig.control_gpio = configBytes[7];
                parsedConfig.led_gpio = configBytes[8];
                parsedConfig.extended_mode = configBytes[11];
            }

            if (this.config_cbr) {
                this.config_cbr(parsedConfig);
            }
        };

        const emitLog = (msgBytes) => {
            const text = new TextDecoder().decode(msgBytes);
            if (this.log_cbr) {
                this.log_cbr({
                    type: 'log_packet',
                    data: msgBytes,
                    text
                });
            }
            /* Resolve any pending log wait */
            if (this.nextLogResolve) {
                this.nextLogResolve(text);
                this.nextLogResolve = null;
                if (this.nextLogTimer) {
                    clearTimeout(this.nextLogTimer);
                    this.nextLogTimer = null;
                }
            }
        };

        const emitSwd = (payload) => {
            if (!payload || payload.length < 12) {
                return;
            }

            const view = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
            const magic = view.getUint16(0, true);
            if (magic !== 0xCAFE) {
                return;
            }

            const op = payload[2] >>> 0;
            const status = payload[3] >>> 0;
            const seq = view.getUint16(4, true) >>> 0;
            const swdio_gpio = payload[6] >>> 0;
            const swclk_gpio = payload[7] >>> 0;
            const ack = payload[8] >>> 0;
            const data_len = view.getUint16(10, true) >>> 0;

            if (payload.length < 12 + data_len) {
                return;
            }

            const data = payload.slice(12, 12 + data_len);
            const packet = {
                type: 'swd_packet',
                op,
                req_op: (op & 0x7F) >>> 0,
                is_response: ((op & 0x80) !== 0),
                status,
                seq,
                swdio_gpio,
                swclk_gpio,
                ack,
                data,
                raw: payload
            };

            const pending = this._swdPending.get(seq);
            if (pending) {
                if (pending.timer) clearTimeout(pending.timer);
                this._swdPending.delete(seq);
                pending.resolve(packet);
                return;
            }
        };

        if (!this.extendedMode) {
            /* In non-extended mode, just pass through all data */
            if (this.rxBuffer.length > 0) {
                emitData(this.rxBuffer);
                this.rxBuffer = new Uint8Array(0);
            }
            return;
        }

        /* Extended mode: parse packet headers */
        while (this.rxBuffer.length >= this.PACKET_HEADER_SIZE) {
            const length = (this.rxBuffer[0] | (this.rxBuffer[1] << 8)) >>> 0;
            const type = (this.rxBuffer[2] | (this.rxBuffer[3] << 8)) >>> 0;

            /* Validate length (must include header, minimum 4) */
            if (length < 4) {
                /* Invalid packet, discard first byte and resync */
                this.rxBuffer = this.rxBuffer.slice(1);
                continue;
            }

            const payloadLen = length - 4;
            const totalLen = this.PACKET_HEADER_SIZE + payloadLen;

            /* Wait for complete packet */
            if (this.rxBuffer.length < totalLen) {
                break;
            }

            /* Extract payload */
            const payload = this.rxBuffer.slice(this.PACKET_HEADER_SIZE, totalLen);
            this.rxBuffer = this.rxBuffer.slice(totalLen);

            /* Handle packet based on type */
            if (type === this.PACKET_TYPE_DATA) {
                /* Type 0x00: Normal serial data */
                emitData(payload);
            } else if (type === this.PACKET_TYPE_CONFIG) {
                /* Type 0x01: Config response */
                emitConfig(payload);
            } else if (type === this.PACKET_TYPE_LOG) {
                /* Type 0x03: Log message */
                emitLog(payload);
            } else if (type === this.UART_PACKET_TYPE_SWD) {
                /* Type 0x04: SWD binary responses */
                emitSwd(payload);
            } else {
                /* Unknown packet type, pass through as data */
                emitData(payload);
            }
        }
    }

    _nextSwdSeq() {
        /* seq=0 reserved */
        let seq = this._swdSeq & 0xFFFF;
        if (seq === 0) seq = 1;
        this._swdSeq = (seq + 1) & 0xFFFF;
        if (this._swdSeq === 0) this._swdSeq = 1;
        return seq;
    }

    _buildSwdRequestPayload(op, flags, seq, args) {
        const a = args ? (args instanceof Uint8Array ? args : new Uint8Array(args)) : new Uint8Array(0);
        const out = new Uint8Array(8 + a.length);
        /* magic 0xCAFE little-endian */
        out[0] = 0xFE;
        out[1] = 0xCA;
        out[2] = op & 0xFF;
        out[3] = flags & 0xFF;
        out[4] = seq & 0xFF;
        out[5] = (seq >> 8) & 0xFF;
        out[6] = 0;
        out[7] = 0;
        if (a.length) out.set(a, 8);
        return out;
    }

    async swdRequest(op, args, options) {
        if (!this.port) throw new Error('Port not connected');
        const opt = options || {};
        const flags = (opt.flags || 0) & 0xFF;
        const timeoutMs = opt.timeoutMs || this._swdDefaultTimeoutMs;
        const seq = (opt.seq !== undefined) ? (opt.seq & 0xFFFF) : this._nextSwdSeq();

        if (this._swdPending.has(seq)) {
            throw new Error(`SWD seq collision: ${seq}`);
        }

        const payload = this._buildSwdRequestPayload(op, flags, seq, args);
        const packet = this.buildPacket(payload, this.UART_PACKET_TYPE_SWD);

        return new Promise(async (resolve, reject) => {
            const timer = setTimeout(() => {
                this._swdPending.delete(seq);
                reject(new Error(`SWD timeout (op=0x${op.toString(16)}, seq=${seq})`));
            }, timeoutMs);

            this._swdPending.set(seq, { resolve, reject, timer });

            try {
                await this.sendPacket(packet, `SWD op=0x${op.toString(16)} seq=${seq}`);
            } catch (err) {
                clearTimeout(timer);
                this._swdPending.delete(seq);
                reject(err);
            }
        });
    }

    waitForSwdResponse(seq, timeoutMs) {
        if (!this.port) throw new Error('Port not connected');
        const s = (seq >>> 0) & 0xFFFF;
        const t = timeoutMs || this._swdDefaultTimeoutMs;

        if (this._swdPending.has(s)) {
            throw new Error(`SWD seq already pending: ${s}`);
        }

        return new Promise((resolve, reject) => {
            const timer = setTimeout(() => {
                this._swdPending.delete(s);
                reject(new Error(`SWD timeout (seq=${s})`));
            }, t);

            this._swdPending.set(s, { resolve, reject, timer });
        });
    }

    async readFromPort() {
        if (!this.port) return;

        try {
            this.reader = this.port.readable.getReader();
            this.inputDone = false;

            while (!this.inputDone && this.port) {
                try {
                    const { value, done } = await this.reader.read();
                    if (done) break;

                    if (value) {
                        /* Log raw RX bytes at lowest level */
                        this.consoleLogHex('RX:', value);
                        this.processEspPackets(value);
                    }
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        logToConsole(`Read error: ${err.message}`, 'info');
                    }
                    break;
                }
            }
        } catch (err) {
            logToConsole(`ReadFromPort error: ${err.message}`, 'info');
        } finally {
            if (this.reader) {
                this.reader.releaseLock();
                this.reader = null;
            }
            if (!this.inputDone && this.port) {
                await this.handlePortDisconnect('read_end');
            }
        }
    }

    async sendData(data) {
        if (!this.port) return;
        try {
            const writer = this.port.writable.getWriter();
            try {
                await this.sendDataWithWriter(writer, data);
            } finally {
                writer.releaseLock();
            }
        } catch (err) {
            logToConsole(`Send data error: ${err.message}`, 'info');
        }
    }

    async sendDataWithWriter(writer, data) {
        /* Fragment data into 64k blocks if needed */
        const maxPayloadSize = 65534;
        let offset = 0;

        while (offset < data.length) {
            const chunkSize = Math.min(maxPayloadSize, data.length - offset);
            const chunk = data.slice(offset, offset + chunkSize);

            const packet = this.buildPacket(chunk, this.PACKET_TYPE_DATA);

            /* Log raw TX bytes at lowest level */
            this.consoleLogHex('TX Data:', packet);
            await writer.write(packet);
            offset += chunkSize;
        }
    }

    async sendPacket(packet, label) {
        if (!this.port) return;
        try {
            const writer = this.port.writable.getWriter();
            try {
                this.consoleLogHex(`TX ${label}:`, packet);
                await writer.write(packet);
            } finally {
                writer.releaseLock();
            }
        } catch (err) {
            logToConsole(`Send packet error: ${err.message}`, 'info');
        }
    }

    async sendBreak() {
        let breakLen = parseInt(document.getElementById('breakLenInput').value) || 200;
        if (breakLen > 200) breakLen = 200;
        if (breakLen < 0) breakLen = 0;
        const commandStr = 'B:' + breakLen;
        const packet = this.buildControlPacket(commandStr);
        await this.sendPacket(packet, 'Break');
    }

    async setResetGpio(value) {
        const command = value ? 'R:1' : 'R:0';
        const packet = this.buildControlPacket(command);
        await this.sendPacket(packet, 'Reset');
    }

    async setControlGpio(value) {
        const command = value ? 'C:1' : 'C:0';
        const packet = this.buildControlPacket(command);
        await this.sendPacket(packet, 'Control');
    }

    async requestConfig() {
        if (!this.port) throw new Error('Port not connected');
        try {
            const payload = new Uint8Array(12);
            payload.fill(0);

            const packet = this.buildPacket(payload, this.PACKET_TYPE_CONFIG);

            /* Track if we received a config response */
            let configReceived = false;
            const originalConfigCbr = this.config_cbr;
            this.config_cbr = (packet) => {
                configReceived = true;
                if (originalConfigCbr) originalConfigCbr(packet);
            };

            await this.sendPacket(packet, 'Config Request');

            /* Wait up to 2 seconds for config response - MUST receive it */
            let waited = 0;
            while (waited < 2000 && !configReceived) {
                await new Promise(resolve => setTimeout(resolve, 50));
                waited += 50;
            }

            this.config_cbr = originalConfigCbr;

            if (!configReceived) {
                throw new Error('Config request timeout - device did not respond');
            }
        } catch (err) {
            logToConsole(`Config request error: ${err.message}`, 'info');
            throw err;
        }
    }

    async setConfig(configData) {
        if (!this.port) return;
        try {
            /* Build 12-byte payload from config structure */
            const payload = new Uint8Array(12);
            payload.fill(0);

            /* baud_rate at offset 0-3 (little-endian) */
            const baud = configData.baud_rate || 0;
            payload[0] = baud & 0xFF;
            payload[1] = (baud >> 8) & 0xFF;
            payload[2] = (baud >> 16) & 0xFF;
            payload[3] = (baud >> 24) & 0xFF;

            /* GPIO pins at offsets 4-8 */
            payload[4] = configData.tx_gpio || 0;
            payload[5] = configData.rx_gpio || 0;
            payload[6] = configData.reset_gpio || 0;
            payload[7] = configData.control_gpio || 0;
            payload[8] = configData.led_gpio || 0;

            /* Padding at offsets 9-10 */
            payload[9] = 0;
            payload[10] = 0;

            /* extended_mode at offset 11 */
            payload[11] = configData.extended_mode || 0;

            const packet = this.buildPacket(payload, this.PACKET_TYPE_CONFIG);

            const writer = this.port.writable.getWriter();
            await writer.write(packet);
            writer.releaseLock();
        } catch (err) {
            logToConsole(`Config send error: ${err.message}`, 'info');
        }
    }

}

window.EspSerial = EspSerial;

</script>
    <script src="https://cdn.jsdelivr.net/npm/@alexaltea/capstone-js@3.0.5/dist/capstone.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(circle at 20% 20%, #1f2937 0%, #0b1220 40%, #070b15 75%);
            min-height: 100vh;
            padding: 24px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            color: #e5e7eb;
        }

        .container {
            max-width: 1000px;
            width: 100%;
            background: linear-gradient(180deg, rgba(31, 41, 55, 0.9), rgba(15, 23, 42, 0.95));
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.55);
            overflow: visible;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .header {
            background: linear-gradient(90deg, #1e3a8a, #0f172a);
            padding: 20px;
            border-bottom: 2px solid #3b82f6;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 15px;
        }

        .connection-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn-primary,
        .btn-secondary {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);
        }

        .btn-primary:disabled {
            background: #6b7280;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .btn-secondary {
            background: #6b7280;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #4b5563;
        }

        .btn-secondary:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        .connection-status {
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            background: #ef4444;
            color: white;
        }

        .connection-status.connected {
            background: #10b981;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: visible;
            padding: 20px;
            gap: 15px;
        }

        .console-display {
            flex: 0 0 auto;
            height: 420px;
            height: 25lh;
            background: #0f172a;
            border: 1px solid #374151;
            border-radius: 6px;
            padding: 12px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #a3e635;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .console-display::-webkit-scrollbar {
            width: 8px;
        }

        .console-display::-webkit-scrollbar-track {
            background: #1f2937;
            border-radius: 4px;
        }

        .console-display::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }

        .console-display::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }

        .controls-section {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            padding: 15px;
            background: rgba(55, 65, 81, 0.3);
            border-radius: 6px;
        }

        .ap-tabs {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .ap-tab {
            padding: 6px 10px;
            border: 1px solid #374151;
            background: #0f172a;
            color: #e5e7eb;
            border-radius: 999px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .ap-tab.active {
            border-color: #60a5fa;
            box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.18);
        }

        .ap-panel {
            background:#0f172a;
            border: 1px solid #374151;
            border-radius: 6px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #e5e7eb;
            white-space: pre-wrap;
            overflow: visible;
            max-height: none;
            min-height: 260px;
        }

        .ap-panel .row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        .ap-subtabs {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
            margin-bottom: 8px;
        }

        .ap-subtab {
            padding: 6px 10px;
            border: 1px solid #374151;
            background: #0b1220;
            color: #e5e7eb;
            border-radius: 999px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .ap-subtab.active {
            border-color: #a3e635;
            box-shadow: 0 0 0 2px rgba(163, 230, 53, 0.15);
        }

        .ap-subtab:disabled {
            opacity: 0.45;
            cursor: not-allowed;
        }

        .ap-subpanel {
            margin-top: 6px;
        }

        .ap-panel input {
            padding: 8px;
            border: 1px solid #4b5563;
            border-radius: 6px;
            background: #1f2937;
            color: #e5e7eb;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .ap-panel input.flash-input {
            border-color: #a3e635 !important;
            box-shadow: 0 0 0 3px rgba(163, 230, 53, 0.18) !important;
            background: #172554 !important;
            transition: all 0.12s ease-in-out;
        }

        .ap-panel button {
            padding: 8px 12px;
            background: #6b7280;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 700;
        }

        .ap-panel button:hover {
            background: #4b5563;
        }

        .hex-editor {
            margin-top: 10px;
            border: 1px solid #374151;
            border-radius: 6px;
            background: #0b1220;
            overflow: hidden;
        }

        .hex-editor .hex-toolbar {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 8px 10px;
            border-bottom: 1px solid #374151;
            background: rgba(31, 41, 55, 0.6);
            color: #e5e7eb;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 12px;
        }

        .hex-editor .hex-toolbar label {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            color: #9ca3af;
            font-weight: 600;
        }

        .hex-editor .hex-toolbar select {
            padding: 6px 8px;
            border: 1px solid #4b5563;
            border-radius: 6px;
            background: #111827;
            color: #e5e7eb;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .hex-editor .hex-view {
            max-height: none;
            min-height: 260px;
            overflow: auto;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #e5e7eb;
            line-height: 1.6;
            user-select: none;
            resize: vertical;
        }

        .hex-editor .hex-row {
            display: grid;
            grid-template-columns: 90px 1fr 180px;
            gap: 12px;
            align-items: start;
            white-space: pre;
        }

        .hex-editor .hex-off {
            color: #9ca3af;
        }

        .hex-editor .hex-bytes {
            color: #e5e7eb;
        }

        .hex-editor .hex-ascii {
            color: #d1d5db;
        }

        .hex-editor .byte {
            display: inline-block;
            width: 22px;
            text-align: center;
            padding: 1px 0;
            border-radius: 4px;
            cursor: default;
        }

        .hex-editor .byte .nib {
            display: inline-block;
            width: 10px;
            text-align: center;
            border-radius: 3px;
        }

        .hex-editor .byte .nib.nsel {
            background: rgba(96, 165, 250, 0.28);
            outline: 1px solid rgba(96, 165, 250, 0.48);
        }

        .disasm-box {
            margin-top: 10px;
            border: 1px solid #374151;
            border-radius: 6px;
            background: #0b1220;
            overflow: hidden;
        }

        .disasm-header {
            padding: 8px 10px;
            border-bottom: 1px solid #374151;
            background: rgba(31, 41, 55, 0.6);
            color: #a3e635;
            font-weight: 800;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 12px;
        }

        .disasm-view {
            padding: 8px 10px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 13px;
            color: #e5e7eb;
            white-space: pre;
            overflow-x: auto;
            max-height: 280px;
        }

        .disasm-line {
            display: block;
            padding: 2px 4px;
            border-radius: 4px;
        }

        .disasm-line.active {
            background: rgba(59, 130, 246, 0.18);
            outline: 1px solid rgba(59, 130, 246, 0.55);
        }

        .hex-editor .byte:hover {
            background: rgba(59, 130, 246, 0.15);
        }

        .hex-editor .byte.dirty {
            background: rgba(245, 158, 11, 0.18);
            outline: 1px solid rgba(245, 158, 11, 0.35);
        }

        .hex-editor .byte.sel {
            background: rgba(96, 165, 250, 0.22);
            outline: 1px solid rgba(96, 165, 250, 0.45);
        }

        .hex-editor .ascii {
            display: inline-block;
            width: 11px;
            text-align: center;
            padding: 1px 0;
            border-radius: 4px;
        }

        .hex-editor .ascii:hover {
            background: rgba(16, 185, 129, 0.12);
        }

        .hex-editor .ascii.dirty {
            background: rgba(245, 158, 11, 0.12);
            outline: 1px solid rgba(245, 158, 11, 0.25);
        }

        .hex-editor .ascii.sel {
            background: rgba(16, 185, 129, 0.18);
            outline: 1px solid rgba(16, 185, 129, 0.35);
        }

        .hex-input-overlay {
            position: fixed;
            z-index: 9999;
            padding: 0;
            margin: 0;
            border: none;
        }

        .hex-input-overlay input {
            padding: 6px 8px;
            border: 1px solid #60a5fa;
            border-radius: 6px;
            background: #111827;
            color: #e5e7eb;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            outline: none;
            width: 110px;
        }

        .input-section {
            display: flex;
            gap: 10px;
        }

        .input-section input {
            flex: 1;
            padding: 10px;
            border: 1px solid #4b5563;
            border-radius: 6px;
            background: #1f2937;
            color: #e5e7eb;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .input-section input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.3);
        }

        .input-section button {
            padding: 10px 20px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .input-section button:hover {
            background: #2563eb;
        }

        .input-section button:active {
            transform: scale(0.98);
        }

        .footer {
            padding: 10px 20px;
            border-top: 1px solid #374151;
            font-size: 12px;
            color: #9ca3af;
            text-align: center;
        }

        .toast-container {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .toast {
            min-width: 260px;
            max-width: 420px;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.10);
            background: rgba(15, 23, 42, 0.92);
            color: #e5e7eb;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.40);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 13px;
            font-weight: 650;
            pointer-events: none;
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.18s ease-out, transform 0.18s ease-out;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        .toast.error {
            border-color: rgba(239, 68, 68, 0.55);
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.12), 0 12px 30px rgba(0, 0, 0, 0.45);
        }

        .toast.error.flash {
            animation: toastFlashRed 0.55s ease-in-out 0s 1;
        }

        @keyframes toastFlashRed {
            0% { background: rgba(127, 29, 29, 0.95); }
            55% { background: rgba(15, 23, 42, 0.92); }
            100% { background: rgba(127, 29, 29, 0.95); }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>SWD Debug Console</h1>
            <div class="connection-controls">
                <button class="btn-primary" id="connectBtn" onclick="connectDevice()">Connect</button>
                <button class="btn-secondary" id="disconnectBtn" onclick="disconnectDevice()"
                    disabled>Disconnect</button>
                <button class="btn-secondary" id="clearBtn" onclick="clearConsole()">Clear</button>
                <div class="connection-status" id="statusIndicator">Disconnected</div>
            </div>
        </div>

        <div class="main-content">
            <div class="controls-section" id="deviceInteraction" style="padding: 12px; display: none;">
                <div style="display: flex; flex-direction: column; gap: 10px; width: 100%;">

                    <div style="display: flex; flex-direction: column; gap: 15px;">
                        <div>
                            <div style="margin-bottom: 8px; color: #a3e635; font-weight: 600;">Candidate GPIOs (SWD+SWC):</div>
                            <div id="ioGpioCheckboxes" style="display: flex; gap: 12px; flex-wrap: wrap;"></div>
                        </div>
                        <button id="btnRunSWDTest" style="padding: 10px 20px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 700; align-self: flex-start;">Detect device</button>

                        <div style="display: grid; grid-template-columns: 220px 1fr; gap: 10px; align-items: center; margin-top: 6px;">
                            <div style="color: #9ca3af; font-weight: 600;">Detected Pins</div>
                            <div id="detectedPins" style="font-family: 'Courier New', monospace; color: #e5e7eb;">-</div>
                            <div style="color: #9ca3af; font-weight: 600;">DPIDR / TARGETID</div>
                            <div id="detectedIds" style="font-family: 'Courier New', monospace; color: #e5e7eb;">-</div>
                        </div>

                        <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                            <button id="btnScanAps" class="btn-secondary" disabled>Scan APs</button>
                            <button id="btnDpDebug" class="btn-secondary" disabled>DP Debug</button>
                            <label style="display:flex; align-items:center; gap:8px; color:#9ca3af; font-weight:600;">
                                Max APs
                                <input id="apScanMaxInput" value="4" style="width: 70px; padding: 8px; border: 1px solid #4b5563; border-radius: 6px; background: #1f2937; color: #e5e7eb; font-family: 'Courier New', monospace; font-size: 13px;" />
                            </label>
                            <label style="display:flex; align-items:center; gap:8px; color:#9ca3af; font-weight:600;">
                                <input id="chkFullApScan" type="checkbox" />
                                Full scan (slow)
                            </label>
                            <label style="display:flex; align-items:center; gap:8px; color:#9ca3af; font-weight:600;">
                                <input id="chkVerboseSwd" type="checkbox" />
                                Verbose SWD logs
                            </label>
                        </div>

                        <div style="margin-top: 8px;">
                            <div style="margin-bottom: 8px; color: #a3e635; font-weight: 600;">AP Scan Results</div>
                            <div id="apTabs" class="ap-tabs"></div>
                            <div id="apPanel" class="ap-panel">(not scanned)</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="console-display" id="consoleDisplay"></div>
        </div>

        <div class="footer">
            Single Wire Debugging utility - Detect SWD target and explore APs
        </div>
    </div>

    <div class="toast-container" id="toastContainer"></div>

    <script>

        /* ============= Global State and UI Functions ============= */
        let espSerial = null;
        let swd = null;
        let scanInProgress = false;

        let detectLoopActive = false;
        let detectLoopToken = 0;

        let tadaaAudio = null;
        let tadaaAudioPrimed = false;
        let tadaaAudioUrl = null;

        const MAX_CONSOLE_LINES = 500;
        const consoleLineBuffer = [];

        /* audio_embed_start */
window.TADAA_MP3_B64 = "SUQzAwAAAAARLlRBTEIAAAARAAAB//5XAGkAbgBkAG8AdwBzAFRQRTEAAAAVAAAB//5NAGkAYwByAG8AcwBvAGYAdABDT01NAAAAJAAAAWVuZ//+AAD//ncAaQBuAGgAaQBzAHQAbwByAHkALgBkAGUAVElUMgAAAC0AAAH//lcAaQBuAGQAbwB3AHMAIAAzAC4AMQAgAC8AIABOAFQAIAAzAC4AeAB4AFRZRVIAAAAFAAAAMTk5MgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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/2GPaXRhhs5ggHP////+VVs313NStUxBTUUzLjkzVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjkzVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5AEXw/wAABmhwAAAAAADNDgAAAAAAGaAAAAAAAAM0AAAABVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVBUEVUQUdFWNAHAACuAAAABAAAAAAAAKAAAAAAAAAAAAcAAAAAAAAATVAzR0FJTl9NSU5NQVgAMDk5LDIwNQsAAAAAAAAATVAzR0FJTl9VTkRPACswMDUsKzAwNSxODAAAAAAAAABSRVBMQVlHQUlOX1RSQUNLX0dBSU4AKzMuMzM1MDAwIGRCCAAAAAAAAABSRVBMQVlHQUlOX1RSQUNLX1BFQUsAMC4yNTM4MDlBUEVUQUdFWNAHAACuAAAABAAAAAAAAIAAAAAAAAAAAFRBR1dpbmRvd3MgMy4xIC8gTlQgMy54eAAAAAAAAAAAAE1pY3Jvc29mdAAAAAAAAAAAAAAAAAAAAAAAAAAAAFdpbmRvd3MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADE5OTJ3aW5oaXN0b3J5LmRlAAAAAAAAAAAAAAAAAAAAAAD/";
/* audio_embed_stop */

        let scannedAps = [];
        let activeAp = null;

        let lastMemAddrText = '0xE000ED00';
        let lastMemWordsText = '16';
        let lastMemUseBlockRead = true;
        let lastMemWriteValueText = '0x00000000';

        const apHexEditors = new Map();
        const apSubTabState = new Map();

        const coresightTreeCache = new Map();

        /* Initialize ESP Serial with callbacks */
        function initializeEspSerial() {
            espSerial = new EspSerial();

            /* Set up log callback */
            espSerial.setLogCallback((packet) => {
                logToConsole(`${packet.text}`, 'log');
            });

            return espSerial;
        }

        /* ============= SWD Host Logic ============= */

        const SWD_UART_MAGIC = 0xCAFE;
        const SWD_UART_OP_DETECT_PINS = 0x01;
        const SWD_UART_OP_DEINIT = 0x02;
        const SWD_UART_OP_TRANSFER = 0x03;
        const SWD_UART_OP_AP_READ = 0x10;
        const SWD_UART_OP_AP_READ_SINGLE = 0x11;
        const SWD_UART_OP_AP_WRITE = 0x12;

        const SWD_UART_STATUS_OK = 0x00;
        const SWD_UART_FLAG_VERBOSE_LOG = 0x01;

        /* DP register address bits A[3:2] (a23 param for SWD_UART_OP_TRANSFER) */
        const DP_A23_ABORT = 0x00;
        const DP_A23_CTRLSTAT = 0x01;
        const DP_A23_SELECT = 0x02;
        const DP_A23_RDBUFF = 0x03;

        /* DP CTRL/STAT power-up bits */
        const CDBGPWRUPREQ = 0x10000000;
        const CDBGPWRUPACK = 0x20000000;
        const CSYSPWRUPREQ = 0x40000000;
        const CSYSPWRUPACK = 0x80000000;

        const AP_IDR = 0xFC;
        const AP_BASE = 0xF8;
        const MEMAP_CSW = 0x00;
        const MEMAP_TAR = 0x04;
        const MEMAP_DRW = 0x0C;

        /* Cortex-M System Control Space (SCS) / CoreDebug registers */
        const SCS_CPUID = 0xE000ED00;
        const SCS_CPACR = 0xE000ED88;
        const SCS_DHCSR = 0xE000EDF0;
        const SCS_DCRSR = 0xE000EDF4;
        const SCS_DCRDR = 0xE000EDF8;

        const SCS_DHCSR_S_HALT = (1 << 17) >>> 0;
        const SCS_DHCSR_S_REGRDY = (1 << 16) >>> 0;
        const SCS_DHCSR_C_MASKINTS = (1 << 3) >>> 0;
        const SCS_DHCSR_C_STEP = (1 << 2) >>> 0;
        const SCS_DHCSR_C_HALT = (1 << 1) >>> 0;
        const SCS_DHCSR_C_DEBUGEN = (1 << 0) >>> 0;
        const SCS_DHCSR_KEY = 0xA05F0000 >>> 0;

        const SCS_DCRSR_RD = 0x00000000;
        const SCS_DCRSR_WR = 0x00010000;

        /* CoreSight component ID offsets */
        const CS_CIDR_OFFS = [0xFF0, 0xFF4, 0xFF8, 0xFFC];
        const CS_PIDR_OFFS = [0xFE0, 0xFE4, 0xFE8, 0xFEC, 0xFD0, 0xFD4, 0xFD8, 0xFDC];

        const CS_DEVARCH = 0xFBC;
        const CS_DEVTYPE = 0xFCC;

        const CIDR_CLASS_ROMTABLE = 0x01;
        const CIDR_CLASS_CORESIGHT = 0x09;

        const ARM_ID = 0x23B;

        function archId(architect, archid) {
            return (((architect & 0x7FF) << 21) | (archid & 0xFFFF)) >>> 0;
        }

        const CORESIGHT_DEVARCH_DESC = new Map([
            /* Ported from orig/adi.c: class0x9_devarch[] (ARM IHI0029E) */
            [archId(ARM_ID, 0x0A00), 'RAS architecture'],
            [archId(ARM_ID, 0x1A01), 'Instrumentation Trace Macrocell (ITM) architecture'],
            [archId(ARM_ID, 0x1A02), 'DWT architecture'],
            [archId(ARM_ID, 0x1A03), 'Flash Patch and Breakpoint unit (FPB) architecture'],
            [archId(ARM_ID, 0x2A04), 'Processor debug architecture (ARMv8-M)'],
            [archId(ARM_ID, 0x6A05), 'Processor debug architecture (ARMv8-R)'],
            [archId(ARM_ID, 0x0A10), 'PC sample-based profiling'],
            [archId(ARM_ID, 0x4A13), 'Embedded Trace Macrocell (ETM) architecture'],
            [archId(ARM_ID, 0x1A14), 'Cross Trigger Interface (CTI) architecture'],
            [archId(ARM_ID, 0x6A15), 'Processor debug architecture (v8.0-A)'],
            [archId(ARM_ID, 0x7A15), 'Processor debug architecture (v8.1-A)'],
            [archId(ARM_ID, 0x8A15), 'Processor debug architecture (v8.2-A)'],
            [archId(ARM_ID, 0x2A16), 'Processor Performance Monitor (PMU) architecture'],
            [archId(ARM_ID, 0x0A17), 'Memory Access Port v2 architecture'],
            [archId(ARM_ID, 0x0A27), 'JTAG Access Port v2 architecture'],
            [archId(ARM_ID, 0x0A31), 'Basic trace router'],
            [archId(ARM_ID, 0x0A37), 'Power requestor'],
            [archId(ARM_ID, 0x0A47), 'Unknown Access Port v2 architecture'],
            [archId(ARM_ID, 0x0A50), 'HSSTP architecture'],
            [archId(ARM_ID, 0x0A63), 'System Trace Macrocell (STM) architecture'],
            [archId(ARM_ID, 0x0A75), 'CoreSight ELA architecture'],
            [archId(ARM_ID, 0x0AF7), 'CoreSight ROM architecture'],
        ]);

        function coresightDevarchDesc(devarch) {
            const v = devarch >>> 0;
            if ((v & (1 << 20)) === 0) return 'not present';
            const id = (v & (0xFFE00000 | 0x0000FFFF)) >>> 0;
            return CORESIGHT_DEVARCH_DESC.get(id) || 'unknown';
        }

        const ADI_PARTNUM = new Map([
            /* Ported from orig/adi.c: dap_part_nums[] */
            ['23b:000', { type: 'Cortex-M3 SCS', full: '(System Control Space)' }],
            ['23b:001', { type: 'Cortex-M3 ITM', full: '(Instrumentation Trace Module)' }],
            ['23b:002', { type: 'Cortex-M3 DWT', full: '(Data Watchpoint and Trace)' }],
            ['23b:003', { type: 'Cortex-M3 FPB', full: '(Flash Patch and Breakpoint)' }],
            ['23b:008', { type: 'Cortex-M0 SCS', full: '(System Control Space)' }],
            ['23b:00a', { type: 'Cortex-M0 DWT', full: '(Data Watchpoint and Trace)' }],
            ['23b:00b', { type: 'Cortex-M0 BPU', full: '(Breakpoint Unit)' }],
            ['23b:00c', { type: 'Cortex-M4 SCS', full: '(System Control Space)' }],
            ['23b:00d', { type: 'CoreSight ETM11', full: '(Embedded Trace)' }],
            ['23b:00e', { type: 'Cortex-M7 FPB', full: '(Flash Patch and Breakpoint)' }],
            ['23b:193', { type: 'SoC-600 TSGEN', full: '(Timestamp Generator)' }],
            ['23b:470', { type: 'Cortex-M1 ROM', full: '(ROM Table)' }],
            ['23b:471', { type: 'Cortex-M0 ROM', full: '(ROM Table)' }],
            ['23b:490', { type: 'Cortex-A15 GIC', full: '(Generic Interrupt Controller)' }],
            ['23b:492', { type: 'Cortex-R52 GICD', full: '(Distributor)' }],
            ['23b:493', { type: 'Cortex-R52 GICR', full: '(Redistributor)' }],
            ['23b:4a1', { type: 'Cortex-A53 ROM', full: '(v8 Memory Map ROM Table)' }],
            ['23b:4a2', { type: 'Cortex-A57 ROM', full: '(ROM Table)' }],
            ['23b:4a3', { type: 'Cortex-A53 ROM', full: '(v7 Memory Map ROM Table)' }],
            ['23b:4a4', { type: 'Cortex-A72 ROM', full: '(ROM Table)' }],
            ['23b:4a9', { type: 'Cortex-A9 ROM', full: '(ROM Table)' }],
            ['23b:4aa', { type: 'Cortex-A35 ROM', full: '(v8 Memory Map ROM Table)' }],
            ['23b:4af', { type: 'Cortex-A15 ROM', full: '(ROM Table)' }],
            ['23b:4b5', { type: 'Cortex-R5 ROM', full: '(ROM Table)' }],
            ['23b:4b8', { type: 'Cortex-R52 ROM', full: '(ROM Table)' }],
            ['23b:4c0', { type: 'Cortex-M0+ ROM', full: '(ROM Table)' }],
            ['23b:4c3', { type: 'Cortex-M3 ROM', full: '(ROM Table)' }],
            ['23b:4c4', { type: 'Cortex-M4 ROM', full: '(ROM Table)' }],
            ['23b:4c7', { type: 'Cortex-M7 PPB ROM', full: '(Private Peripheral Bus ROM Table)' }],
            ['23b:4c8', { type: 'Cortex-M7 ROM', full: '(ROM Table)' }],
            ['23b:4e0', { type: 'Cortex-A35 ROM', full: '(v7 Memory Map ROM Table)' }],
            ['23b:4e4', { type: 'Cortex-A76 ROM', full: '(ROM Table)' }],
            ['23b:906', { type: 'CoreSight CTI', full: '(Cross Trigger)' }],
            ['23b:907', { type: 'CoreSight ETB', full: '(Trace Buffer)' }],
            ['23b:908', { type: 'CoreSight CSTF', full: '(Trace Funnel)' }],
            ['23b:909', { type: 'CoreSight ATBR', full: '(Advanced Trace Bus Replicator)' }],
            ['23b:910', { type: 'CoreSight ETM9', full: '(Embedded Trace)' }],
            ['23b:912', { type: 'CoreSight TPIU', full: '(Trace Port Interface Unit)' }],
            ['23b:913', { type: 'CoreSight ITM', full: '(Instrumentation Trace Macrocell)' }],
            ['23b:914', { type: 'CoreSight SWO', full: '(Single Wire Output)' }],
            ['23b:917', { type: 'CoreSight HTM', full: '(AHB Trace Macrocell)' }],
            ['23b:920', { type: 'CoreSight ETM11', full: '(Embedded Trace)' }],
            ['23b:921', { type: 'Cortex-A8 ETM', full: '(Embedded Trace)' }],
            ['23b:922', { type: 'Cortex-A8 CTI', full: '(Cross Trigger)' }],
            ['23b:923', { type: 'Cortex-M3 TPIU', full: '(Trace Port Interface Unit)' }],
            ['23b:924', { type: 'Cortex-M3 ETM', full: '(Embedded Trace)' }],
            ['23b:925', { type: 'Cortex-M4 ETM', full: '(Embedded Trace)' }],
            ['23b:930', { type: 'Cortex-R4 ETM', full: '(Embedded Trace)' }],
            ['23b:931', { type: 'Cortex-R5 ETM', full: '(Embedded Trace)' }],
            ['23b:932', { type: 'CoreSight MTB-M0+', full: '(Micro Trace Buffer)' }],
            ['23b:941', { type: 'CoreSight TPIU-Lite', full: '(Trace Port Interface Unit)' }],
            ['23b:950', { type: 'Cortex-A9 PTM', full: '(Program Trace Macrocell)' }],
            ['23b:955', { type: 'Cortex-A5 ETM', full: '(Embedded Trace)' }],
            ['23b:95a', { type: 'Cortex-A72 ETM', full: '(Embedded Trace)' }],
            ['23b:95b', { type: 'Cortex-A17 PTM', full: '(Program Trace Macrocell)' }],
            ['23b:95d', { type: 'Cortex-A53 ETM', full: '(Embedded Trace)' }],
            ['23b:95e', { type: 'Cortex-A57 ETM', full: '(Embedded Trace)' }],
            ['23b:95f', { type: 'Cortex-A15 PTM', full: '(Program Trace Macrocell)' }],
            ['23b:961', { type: 'CoreSight TMC', full: '(Trace Memory Controller)' }],
            ['23b:962', { type: 'CoreSight STM', full: '(System Trace Macrocell)' }],
            ['23b:975', { type: 'Cortex-M7 ETM', full: '(Embedded Trace)' }],
            ['23b:9a0', { type: 'CoreSight PMU', full: '(Performance Monitoring Unit)' }],
            ['23b:9a1', { type: 'Cortex-M4 TPIU', full: '(Trace Port Interface Unit)' }],
            ['23b:9a4', { type: 'CoreSight GPR', full: '(Granular Power Requester)' }],
            ['23b:9a5', { type: 'Cortex-A5 PMU', full: '(Performance Monitor Unit)' }],
            ['23b:9a7', { type: 'Cortex-A7 PMU', full: '(Performance Monitor Unit)' }],
            ['23b:9a8', { type: 'Cortex-A53 CTI', full: '(Cross Trigger)' }],
            ['23b:9a9', { type: 'Cortex-M7 TPIU', full: '(Trace Port Interface Unit)' }],
            ['23b:9ae', { type: 'Cortex-A17 PMU', full: '(Performance Monitor Unit)' }],
            ['23b:9af', { type: 'Cortex-A15 PMU', full: '(Performance Monitor Unit)' }],
            ['23b:9b6', { type: 'Cortex-R52 PMU/CTI/ETM', full: '(Performance Monitor Unit/Cross Trigger/ETM)' }],
            ['23b:9b7', { type: 'Cortex-R7 PMU', full: '(Performance Monitor Unit)' }],
            ['23b:9d3', { type: 'Cortex-A53 PMU', full: '(Performance Monitor Unit)' }],
            ['23b:9d7', { type: 'Cortex-A57 PMU', full: '(Performance Monitor Unit)' }],
            ['23b:9d8', { type: 'Cortex-A72 PMU', full: '(Performance Monitor Unit)' }],
            ['23b:9da', { type: 'Cortex-A35 PMU/CTI/ETM', full: '(Performance Monitor Unit/Cross Trigger/ETM)' }],
            ['23b:9e2', { type: 'SoC-600 APB-AP', full: '(APB4 Memory Access Port)' }],
            ['23b:9e3', { type: 'SoC-600 AHB-AP', full: '(AHB5 Memory Access Port)' }],
            ['23b:9e4', { type: 'SoC-600 AXI-AP', full: '(AXI Memory Access Port)' }],
            ['23b:9e5', { type: 'SoC-600 APv1 Adapter', full: '(Access Port v1 Adapter)' }],
            ['23b:9e6', { type: 'SoC-600 JTAG-AP', full: '(JTAG Access Port)' }],
            ['23b:9e7', { type: 'SoC-600 TPIU', full: '(Trace Port Interface Unit)' }],
            ['23b:9e8', { type: 'SoC-600 TMC ETR/ETS', full: '(Embedded Trace Router/Streamer)' }],
            ['23b:9e9', { type: 'SoC-600 TMC ETB', full: '(Embedded Trace Buffer)' }],
            ['23b:9ea', { type: 'SoC-600 TMC ETF', full: '(Embedded Trace FIFO)' }],
            ['23b:9eb', { type: 'SoC-600 ATB Funnel', full: '(Trace Funnel)' }],
            ['23b:9ec', { type: 'SoC-600 ATB Replicator', full: '(Trace Replicator)' }],
            ['23b:9ed', { type: 'SoC-600 CTI', full: '(Cross Trigger)' }],
            ['23b:9ee', { type: 'SoC-600 CATU', full: '(Address Translation Unit)' }],
            ['23b:c05', { type: 'Cortex-A5 Debug', full: '(Debug Unit)' }],
            ['23b:c07', { type: 'Cortex-A7 Debug', full: '(Debug Unit)' }],
            ['23b:c08', { type: 'Cortex-A8 Debug', full: '(Debug Unit)' }],
            ['23b:c09', { type: 'Cortex-A9 Debug', full: '(Debug Unit)' }],
            ['23b:c0e', { type: 'Cortex-A17 Debug', full: '(Debug Unit)' }],
            ['23b:c0f', { type: 'Cortex-A15 Debug', full: '(Debug Unit)' }],
            ['23b:c14', { type: 'Cortex-R4 Debug', full: '(Debug Unit)' }],
            ['23b:c15', { type: 'Cortex-R5 Debug', full: '(Debug Unit)' }],
            ['23b:c17', { type: 'Cortex-R7 Debug', full: '(Debug Unit)' }],
            ['23b:d03', { type: 'Cortex-A53 Debug', full: '(Debug Unit)' }],
            ['23b:d04', { type: 'Cortex-A35 Debug', full: '(Debug Unit)' }],
            ['23b:d07', { type: 'Cortex-A57 Debug', full: '(Debug Unit)' }],
            ['23b:d08', { type: 'Cortex-A72 Debug', full: '(Debug Unit)' }],
            ['23b:d0b', { type: 'Cortex-A76 Debug', full: '(Debug Unit)' }],
            ['23b:d0c', { type: 'Neoverse N1', full: '(Debug Unit)' }],
            ['23b:d13', { type: 'Cortex-R52 Debug', full: '(Debug Unit)' }],
            ['23b:d49', { type: 'Neoverse N2', full: '(Debug Unit)' }],
            ['17:120', { type: 'TI SDTI', full: '(System Debug Trace Interface)' }],
            ['17:343', { type: 'TI DAPCTL', full: '' }],
            ['17:9af', { type: 'MSP432 ROM', full: '(ROM Table)' }],
            ['1f:cd0', { type: 'Atmel CPU with DSU', full: '(CPU)' }],
            ['41:1db', { type: 'XMC4500 ROM', full: '(ROM Table)' }],
            ['41:1df', { type: 'XMC4700/4800 ROM', full: '(ROM Table)' }],
            ['41:1ed', { type: 'XMC1000 ROM', full: '(ROM Table)' }],
            ['65:000', { type: 'SHARC+/Blackfin+', full: '' }],
            ['70:440', { type: 'Qualcomm QDSS Component v1', full: '(Qualcomm Designed CoreSight Component v1)' }],
            ['bf:100', { type: 'Brahma-B53 Debug', full: '(Debug Unit)' }],
            ['bf:9d3', { type: 'Brahma-B53 PMU', full: '(Performance Monitor Unit)' }],
            ['bf:4a1', { type: 'Brahma-B53 ROM', full: '(ROM Table)' }],
            ['bf:721', { type: 'Brahma-B53 ROM', full: '(ROM Table)' }],
            ['1eb:181', { type: 'Tegra 186 ROM', full: '(ROM Table)' }],
            ['1eb:202', { type: 'Denver ETM', full: '(Denver Embedded Trace)' }],
            ['1eb:211', { type: 'Tegra 210 ROM', full: '(ROM Table)' }],
            ['1eb:302', { type: 'Denver Debug', full: '(Debug Unit)' }],
            ['1eb:402', { type: 'Denver PMU', full: '(Performance Monitor Unit)' }],
            ['20:410', { type: 'STM32F10 (med)', full: '(ROM Table)' }],
            ['20:411', { type: 'STM32F2', full: '(ROM Table)' }],
            ['20:412', { type: 'STM32F10 (low)', full: '(ROM Table)' }],
            ['20:413', { type: 'STM32F40/41', full: '(ROM Table)' }],
            ['20:414', { type: 'STM32F10 (high)', full: '(ROM Table)' }],
            ['20:415', { type: 'STM32L47/48', full: '(ROM Table)' }],
            ['20:416', { type: 'STM32L1xxx6/8/B', full: '(ROM Table)' }],
            ['20:417', { type: 'STM32L05/06', full: '(ROM Table)' }],
            ['20:418', { type: 'STM32F105xx/107', full: '(ROM Table)' }],
            ['20:419', { type: 'STM32F42/43', full: '(ROM Table)' }],
            ['20:420', { type: 'STM32F10 (med)', full: '(ROM Table)' }],
            ['20:421', { type: 'STM32F446xx', full: '(ROM Table)' }],
            ['20:422', { type: 'STM32FF358/02/03', full: '(ROM Table)' }],
            ['20:423', { type: 'STM32F401xB/C', full: '(ROM Table)' }],
            ['20:425', { type: 'STM32L031/41', full: '(ROM Table)' }],
            ['20:427', { type: 'STM32L1xxxC', full: '(ROM Table)' }],
            ['20:428', { type: 'STM32F10 (high)', full: '(ROM Table)' }],
            ['20:429', { type: 'STM32L1xxx6A/8A/BA', full: '(ROM Table)' }],
            ['20:430', { type: 'STM32F10 (xl)', full: '(ROM Table)' }],
            ['20:431', { type: 'STM32F411xx', full: '(ROM Table)' }],
            ['20:432', { type: 'STM32F373/8', full: '(ROM Table)' }],
            ['20:433', { type: 'STM32F401xD/E', full: '(ROM Table)' }],
            ['20:434', { type: 'STM32F469/79', full: '(ROM Table)' }],
            ['20:435', { type: 'STM32L43/44', full: '(ROM Table)' }],
            ['20:436', { type: 'STM32L1xxxD', full: '(ROM Table)' }],
            ['20:437', { type: 'STM32L1xxxE', full: '(ROM Table)' }],
            ['20:438', { type: 'STM32F303/34/28', full: '(ROM Table)' }],
            ['20:439', { type: 'STM32F301/02/18', full: '(ROM Table)' }],
            ['20:440', { type: 'STM32F03/5', full: '(ROM Table)' }],
            ['20:441', { type: 'STM32F412xx', full: '(ROM Table)' }],
            ['20:442', { type: 'STM32F03/9', full: '(ROM Table)' }],
            ['20:444', { type: 'STM32F03xx4', full: '(ROM Table)' }],
            ['20:445', { type: 'STM32F04/7', full: '(ROM Table)' }],
            ['20:446', { type: 'STM32F302/03/98', full: '(ROM Table)' }],
            ['20:447', { type: 'STM32L07/08', full: '(ROM Table)' }],
            ['20:448', { type: 'STM32F070/1/2', full: '(ROM Table)' }],
            ['20:449', { type: 'STM32F74/5', full: '(ROM Table)' }],
            ['20:450', { type: 'STM32H74/5', full: '(ROM Table)' }],
            ['20:451', { type: 'STM32F76/7', full: '(ROM Table)' }],
            ['20:452', { type: 'STM32F72/3', full: '(ROM Table)' }],
            ['20:457', { type: 'STM32L01/2', full: '(ROM Table)' }],
            ['20:458', { type: 'STM32F410xx', full: '(ROM Table)' }],
            ['20:460', { type: 'STM32G07/8', full: '(ROM Table)' }],
            ['20:461', { type: 'STM32L496/A6', full: '(ROM Table)' }],
            ['20:462', { type: 'STM32L45/46', full: '(ROM Table)' }],
            ['20:463', { type: 'STM32F413/23', full: '(ROM Table)' }],
            ['20:464', { type: 'STM32L412/22', full: '(ROM Table)' }],
            ['20:466', { type: 'STM32G03/04', full: '(ROM Table)' }],
            ['20:468', { type: 'STM32G431/41', full: '(ROM Table)' }],
            ['20:469', { type: 'STM32G47/48', full: '(ROM Table)' }],
            ['20:470', { type: 'STM32L4R/S', full: '(ROM Table)' }],
            ['20:471', { type: 'STM32L4P5/Q5', full: '(ROM Table)' }],
            ['20:479', { type: 'STM32G491xx', full: '(ROM Table)' }],
            ['20:480', { type: 'STM32H7A/B', full: '(ROM Table)' }],
            ['20:495', { type: 'STM32WB50/55', full: '(ROM Table)' }],
            ['20:497', { type: 'STM32WLE5xx', full: '(ROM Table)' }],
        ]);

        function adiPartNumLookup(designer, part) {
            const key = `${(designer >>> 0).toString(16)}:${(part >>> 0).toString(16).padStart(3, '0')}`;
            return ADI_PARTNUM.get(key) || { type: 'Unrecognized', full: `D:${(designer >>> 0).toString(16)} P:${(part >>> 0).toString(16)}` };
        }

        function u32ToHex(v) {
            const x = (v >>> 0).toString(16).toUpperCase().padStart(8, '0');
            return `0x${x}`;
        }

        function readU32LE(bytes, off = 0) {
            return ((bytes[off] >>> 0) |
                ((bytes[off + 1] >>> 0) << 8) |
                ((bytes[off + 2] >>> 0) << 16) |
                ((bytes[off + 3] >>> 0) << 24)) >>> 0;
        }

        function u32FromBytesLE(bytes, off = 0) {
            return readU32LE(bytes, off) >>> 0;
        }

        function writeU32LE(dst, off, v) {
            const x = v >>> 0;
            dst[off] = x & 0xFF;
            dst[off + 1] = (x >>> 8) & 0xFF;
            dst[off + 2] = (x >>> 16) & 0xFF;
            dst[off + 3] = (x >>> 24) & 0xFF;
        }

        function parseHexOrDec(text) {
            const s = (text || '').trim();
            if (s.startsWith('0x') || s.startsWith('0X')) return parseInt(s.substring(2), 16) >>> 0;
            return parseInt(s, 10) >>> 0;
        }

        function bytesToHex2(b) {
            return (b & 0xFF).toString(16).toUpperCase().padStart(2, '0');
        }

        async function ensureCapstoneReady() {
            if (!window.cs) throw new Error('Capstone not loaded (missing capstone.min.js)');
            try {
                if (cs.MCapstone && typeof cs.MCapstone.then === 'function') {
                    await cs.MCapstone;
                }
            } catch (e) {
                throw new Error(`Capstone init failed: ${e && e.message ? e.message : e}`);
            }
            if (!cs.Capstone) throw new Error('Capstone API missing');
            return true;
        }

        function showToast(message, kind = 'error', opts = {}) {
            const container = document.getElementById('toastContainer');
            if (!container) return;
            const text = (message === null || message === undefined) ? '' : String(message);
            const timeoutMs = (opts && opts.timeoutMs) ? (opts.timeoutMs | 0) : 2200;

            const el = document.createElement('div');
            el.className = `toast ${kind}`;
            el.textContent = text;
            container.appendChild(el);

            /* trigger transition */
            requestAnimationFrame(() => {
                el.classList.add('show');
                if (kind === 'error') el.classList.add('flash');
            });

            setTimeout(() => {
                try { el.classList.remove('show'); } catch (e) { /* ignore */ }
                setTimeout(() => {
                    try { el.remove(); } catch (e) { /* ignore */ }
                }, 240);
            }, Math.max(400, timeoutMs));
        }

        function flashInput(el, ms = 420) {
            if (!el) return;
            try {
                const prev = el.dataset.flashTimerId;
                if (prev) {
                    clearTimeout(parseInt(prev, 10));
                }
                el.classList.remove('flash-input');
                void el.offsetWidth;
                el.classList.add('flash-input');
                const tid = setTimeout(() => {
                    try { el.classList.remove('flash-input'); } catch (e) { /* ignore */ }
                    try { delete el.dataset.flashTimerId; } catch (e) { /* ignore */ }
                }, Math.max(80, ms | 0));
                el.dataset.flashTimerId = String(tid);
            } catch (e) {
                /* ignore */
            }
        }

        function isPrintableAscii(code) {
            return code >= 0x20 && code <= 0x7E;
        }

        class HexEditor {
            constructor(opts = {}) {
                this.bytesPerRow = opts.bytesPerRow || 16;
                this.baseAddr = 0;
                this.data = new Uint8Array(0);
                this.onChange = opts.onChange || null;
                this.onModeChange = opts.onModeChange || null;
                this.editMode = 'byte';
                /* Dirty tracking is per-byte. UI/write-back can group bytes into
                 * 8/16/32-bit regions depending on selected width.
                 */
                this._dirtyBytes = new Uint8Array(0);
                this._dirtyCount = 0;
                this._dirtyRegionSize = this._editSizeBytes(); /* bytes: 1,2,4 */
                this._root = null;
                this._view = null;
                this._selIndex = null;
                this._selKind = 'hex';
                this._selNibble = null;
                this._overlay = null;
                this._boundKeyDown = (e) => this._onKeyDown(e);
                this._boundClick = (e) => this._onClick(e);
                this._boundDblClick = (e) => this._onDblClick(e);
            }

            _targetCellEl(rawTarget) {
                /* Some browsers report a Text node as the event target when double-clicking.
                 * Normalize to the nearest element carrying data-kind/data-index.
                 */
                if (!rawTarget) return null;
                let el = rawTarget;
                try {
                    if (el.nodeType === 3) el = el.parentElement; /* TEXT_NODE */
                } catch (e) {
                    /* ignore */
                }
                if (!el) return null;
                if (el.dataset && el.dataset.kind && el.dataset.index !== undefined) return el;
                try {
                    if (el.closest) {
                        return el.closest('[data-kind][data-index]');
                    }
                } catch (e) {
                    /* ignore */
                }
                return null;
            }

            render(containerEl) {
                if (!containerEl) return;
                containerEl.innerHTML = '';

                const root = document.createElement('div');
                root.className = 'hex-editor';
                root.tabIndex = 0;

                const toolbar = document.createElement('div');
                toolbar.className = 'hex-toolbar';

                const title = document.createElement('div');
                title.style.fontWeight = '800';
                title.textContent = 'Hex viewer';

                const modeLabel = document.createElement('label');
                modeLabel.textContent = 'Edit:';
                const modeSel = document.createElement('select');
                const addOpt = (v, t) => {
                    const o = document.createElement('option');
                    o.value = v;
                    o.textContent = t;
                    modeSel.appendChild(o);
                };
                addOpt('byte', 'byte');
                addOpt('word', 'word (16-bit)');
                addOpt('dword', 'dword (32-bit)');
                modeSel.value = this.editMode;
                modeSel.onchange = () => {
                    this.editMode = modeSel.value;
                    this.setDirtyRegionSize(this._editSizeBytes());
                    if (this.onModeChange) {
                        try { this.onModeChange({ editMode: this.editMode, widthBytes: this._editSizeBytes() }); } catch (e) { /* ignore */ }
                    }
                };
                modeLabel.appendChild(modeSel);

                const meta = document.createElement('div');
                meta.style.marginLeft = 'auto';
                meta.style.color = '#9ca3af';
                meta.textContent = 'Tip: click to select, double-click to edit, type in ASCII view';

                toolbar.appendChild(title);
                toolbar.appendChild(modeLabel);
                toolbar.appendChild(meta);

                const view = document.createElement('div');
                view.className = 'hex-view';

                root.appendChild(toolbar);
                root.appendChild(view);

                root.addEventListener('keydown', this._boundKeyDown);
                root.addEventListener('click', this._boundClick);
                root.addEventListener('dblclick', this._boundDblClick);

                this._root = root;
                this._view = view;
                containerEl.appendChild(root);
                this._renderView();
            }

            setData(bytes, baseAddr = 0) {
                this.data = bytes ? new Uint8Array(bytes) : new Uint8Array(0);
                this.baseAddr = baseAddr >>> 0;
                this._selIndex = null;
                this._selKind = 'hex';
                this._selNibble = null;
                this._dirtyBytes = new Uint8Array(this.data.length);
                this._dirtyCount = 0;
                this._renderView();
            }

            isDirty() {
                return this._dirtyCount > 0;
            }

            clearDirty() {
                if (this._dirtyBytes && this._dirtyBytes.length) {
                    this._dirtyBytes.fill(0);
                }
                this._dirtyCount = 0;
            }

            markDirty(startByte, lengthBytes) {
                const s = Math.max(0, startByte | 0);
                const e = Math.min(this.data.length, (s + (lengthBytes | 0)) | 0);
                if (e <= s) return;
                if (!this._dirtyBytes || this._dirtyBytes.length !== this.data.length) {
                    this._dirtyBytes = new Uint8Array(this.data.length);
                    this._dirtyCount = 0;
                }
                for (let i = s; i < e; i++) {
                    if (this._dirtyBytes[i] === 0) {
                        this._dirtyBytes[i] = 1;
                        this._dirtyCount++;
                    }
                }
            }

            setDirtyRegionSize(bytes) {
                const v = bytes | 0;
                if (v === 1 || v === 2 || v === 4) {
                    this._dirtyRegionSize = v;
                    this._renderView();
                }
            }

            getDirtyRegionSize() {
                return this._dirtyRegionSize | 0;
            }

            _isRegionDirty(byteIndex, regionSize) {
                if (!this._dirtyBytes || this._dirtyCount === 0) return false;
                const rs = (regionSize | 0) || 1;
                const start = (byteIndex & ~(rs - 1)) | 0;
                const end = Math.min(this.data.length, start + rs);
                for (let i = start; i < end; i++) {
                    if (this._dirtyBytes[i]) return true;
                }
                return false;
            }

            getDirtyRanges(regionSizeBytes) {
                const rs = (regionSizeBytes | 0) || 1;
                if (!(rs === 1 || rs === 2 || rs === 4)) throw new Error('getDirtyRanges: bad region size');
                if (!this._dirtyBytes || this._dirtyCount === 0) return [];

                const regions = new Set();
                for (let i = 0; i < this._dirtyBytes.length; i++) {
                    if (!this._dirtyBytes[i]) continue;
                    regions.add((i & ~(rs - 1)) | 0);
                }

                if (regions.size === 0) return [];
                const starts = Array.from(regions).sort((a, b) => a - b);
                const ranges = [];
                let start = starts[0];
                let prev = starts[0];
                for (let i = 1; i < starts.length; i++) {
                    const v = starts[i];
                    if (v === (prev + rs)) {
                        prev = v;
                        continue;
                    }
                    ranges.push({ start, length: (prev - start + rs) });
                    start = v;
                    prev = v;
                }
                ranges.push({ start, length: (prev - start + rs) });
                return ranges;
            }

            countDirtyRegions(regionSizeBytes) {
                const rs = (regionSizeBytes | 0) || 1;
                const ranges = this.getDirtyRanges(rs);
                let total = 0;
                for (const rg of ranges) total += (rg.length / rs) | 0;
                return total | 0;
            }

            getData() {
                return new Uint8Array(this.data);
            }

            _renderView() {
                if (!this._view) return;
                const view = this._view;
                view.innerHTML = '';

                if (!this.data || this.data.length === 0) {
                    const empty = document.createElement('div');
                    empty.style.color = '#9ca3af';
                    empty.textContent = '(no data)';
                    view.appendChild(empty);
                    return;
                }

                const bpr = this.bytesPerRow;
                const rows = Math.ceil(this.data.length / bpr);
                for (let r = 0; r < rows; r++) {
                    const rowStart = r * bpr;
                    const rowEnd = Math.min(this.data.length, rowStart + bpr);

                    const row = document.createElement('div');
                    row.className = 'hex-row';

                    const off = document.createElement('div');
                    off.className = 'hex-off';
                    off.textContent = u32ToHex((this.baseAddr + rowStart) >>> 0);

                    const hex = document.createElement('div');
                    hex.className = 'hex-bytes';
                    const ascii = document.createElement('div');
                    ascii.className = 'hex-ascii';

                    for (let i = 0; i < bpr; i++) {
                        const idx = rowStart + i;

                        if (i === 8) {
                            const gap = document.createTextNode(' ');
                            hex.appendChild(gap);
                        }

                        if (idx < rowEnd) {
                            const b = this.data[idx] & 0xFF;
                            const dirty = this._isRegionDirty(idx, this._dirtyRegionSize);

                            const hx = bytesToHex2(b);

                            const s = document.createElement('span');
                            s.className = 'byte';
                            s.dataset.kind = 'hex';
                            s.dataset.index = String(idx);
                            const n0 = document.createElement('span');
                            n0.className = 'nib';
                            n0.dataset.kind = 'hex';
                            n0.dataset.index = String(idx);
                            n0.dataset.nib = '0';
                            n0.textContent = hx[0];

                            const n1 = document.createElement('span');
                            n1.className = 'nib';
                            n1.dataset.kind = 'hex';
                            n1.dataset.index = String(idx);
                            n1.dataset.nib = '1';
                            n1.textContent = hx[1];

                            if (this._selIndex === idx && this._selKind === 'hex' && (this._selNibble === 0 || this._selNibble === 1)) {
                                if (this._selNibble === 0) n0.classList.add('nsel');
                                if (this._selNibble === 1) n1.classList.add('nsel');
                            }

                            s.appendChild(n0);
                            s.appendChild(n1);
                            if (dirty) s.classList.add('dirty');
                            if (this._selIndex === idx && this._selKind === 'hex') s.classList.add('sel');
                            hex.appendChild(s);
                            hex.appendChild(document.createTextNode(' '));

                            const a = document.createElement('span');
                            a.className = 'ascii';
                            a.dataset.kind = 'ascii';
                            a.dataset.index = String(idx);
                            a.textContent = isPrintableAscii(b) ? String.fromCharCode(b) : '.';
                            if (dirty) a.classList.add('dirty');
                            if (this._selIndex === idx && this._selKind === 'ascii') a.classList.add('sel');
                            ascii.appendChild(a);
                        } else {
                            hex.appendChild(document.createTextNode('   '));
                            ascii.appendChild(document.createTextNode(' '));
                        }
                    }

                    row.appendChild(off);
                    row.appendChild(hex);
                    row.appendChild(ascii);
                    view.appendChild(row);
                }
            }

            _select(index, kind) {
                if (index === null || index === undefined) return;
                const idx = index | 0;
                if (idx < 0 || idx >= this.data.length) return;
                this._selIndex = idx;
                this._selKind = kind || 'hex';
                this._selNibble = null;
                this._renderView();
            }

            _nextIndex(delta) {
                if (this._selIndex === null || this._selIndex === undefined) return;
                const n = Math.max(0, Math.min(this.data.length - 1, (this._selIndex + delta) | 0));
                this._selIndex = n;
                this._selNibble = null;
                this._renderView();
            }

            _onClick(e) {
                /* When double-clicking, the browser fires click twice then dblclick.
                 * If we re-render on the 2nd click, we detach the target element and the
                 * dblclick overlay positioning breaks. Let dblclick handle it.
                 */
                if (e && e.detail && e.detail > 1) return;
                const t = this._targetCellEl(e.target);
                if (!t || !t.dataset) return;
                const kind = t.dataset.kind;
                const idx = t.dataset.index;
                if (kind && idx !== undefined) {
                    this._select(parseInt(idx, 10), kind);
                    if (this._root) this._root.focus();
                }
            }

            _onDblClick(e) {
                let t = this._targetCellEl(e.target);

                /* Some dblclicks land on whitespace/text nodes between spans.
                 * Try resolving the actual element under the pointer.
                 */
                try {
                    if ((!t || !t.dataset) && e && typeof e.clientX === 'number' && typeof e.clientY === 'number') {
                        const under = document.elementFromPoint(e.clientX, e.clientY);
                        t = this._targetCellEl(under);
                    }
                } catch (err) {
                    /* ignore */
                }

                /* Final fallback: start edit at current selection. */
                if (!t || !t.dataset) {
                    if (this._selIndex === null || this._selIndex === undefined) return;
                    try {
                        const q = this._view ? this._view.querySelector(`[data-kind="${this._selKind}"][data-index="${this._selIndex}"]`) : null;
                        if (q && q.dataset) t = q;
                    } catch (err) {
                        /* ignore */
                    }
                }

                if (!t || !t.dataset) return;
                const kind = t.dataset.kind;
                const idxStr = t.dataset.index;
                if (!kind || idxStr === undefined) return;
                const idx = parseInt(idxStr, 10);

                /* IMPORTANT: do not call _select() here.
                 * _select() re-renders the view, which detaches the clicked element and breaks
                 * getBoundingClientRect() positioning for the overlay input.
                 */
                this._selIndex = idx;
                this._selKind = kind;

                if (kind === 'hex') {
                    /* Inline nibble overwrite editing: start at first nibble. */
                    this._selNibble = 0;
                    this._renderView();
                    return;
                }

                this._selNibble = null;
                if (kind === 'ascii') {
                    this._beginAsciiEditAtTarget(t, idx);
                }
            }

            _editSizeBytes() {
                if (this.editMode === 'dword') return 4;
                if (this.editMode === 'word') return 2;
                return 1;
            }

            getEditSizeBytes() {
                return this._editSizeBytes() | 0;
            }

            _alignedIndex(index) {
                const size = this._editSizeBytes();
                if (size <= 1) return index;
                return index & ~(size - 1);
            }

            _beginHexEditAtTarget(targetEl, index) {
                const start = this._alignedIndex(index);
                const size = this._editSizeBytes();
                if (start < 0 || (start + size) > this.data.length) return;

                const rect = targetEl.getBoundingClientRect();
                const overlay = document.createElement('div');
                overlay.className = 'hex-input-overlay';
                overlay.style.left = `${Math.max(8, rect.left)}px`;
                overlay.style.top = `${Math.max(8, rect.top - 2)}px`;

                const input = document.createElement('input');
                const current = [];
                for (let i = 0; i < size; i++) current.push(bytesToHex2(this.data[start + i]));
                input.value = current.join('');
                input.maxLength = size * 2;
                input.placeholder = (size === 1) ? '00' : (size === 2) ? '0000' : '00000000';

                const finish = (commit) => {
                    this._endOverlay();
                    if (!commit) return;
                    const text = (input.value || '').trim();
                    if (!/^[0-9a-fA-F]+$/.test(text) || text.length !== (size * 2)) return;
                    for (let i = 0; i < size; i++) {
                        const byteText = text.substr(i * 2, 2);
                        this.data[start + i] = parseInt(byteText, 16) & 0xFF;
                    }
                    this.markDirty(start, size);
                    if (this.onChange) this.onChange({ start, length: size, kind: 'hex' });
                    this._select(start, 'hex');
                };

                input.addEventListener('keydown', (ev) => {
                    if (ev.key === 'Enter') {
                        ev.preventDefault();
                        finish(true);
                    } else if (ev.key === 'Escape') {
                        ev.preventDefault();
                        finish(false);
                    }
                });

                input.addEventListener('blur', () => finish(true));

                overlay.appendChild(input);
                document.body.appendChild(overlay);
                this._overlay = overlay;
                input.focus();
                input.select();
            }

            _beginAsciiEditAtTarget(targetEl, index) {
                if (index < 0 || index >= this.data.length) return;
                const rect = targetEl.getBoundingClientRect();
                const overlay = document.createElement('div');
                overlay.className = 'hex-input-overlay';
                overlay.style.left = `${Math.max(8, rect.left)}px`;
                overlay.style.top = `${Math.max(8, rect.top - 2)}px`;

                const input = document.createElement('input');
                input.value = isPrintableAscii(this.data[index]) ? String.fromCharCode(this.data[index]) : '';
                input.maxLength = 1;
                input.placeholder = '.';
                input.style.width = '40px';

                const finish = (commit) => {
                    this._endOverlay();
                    if (!commit) return;
                    const v = (input.value || '');
                    if (!v.length) return;
                    const code = v.charCodeAt(0) & 0xFF;
                    this.data[index] = code;
                    this.markDirty(index, 1);
                    if (this.onChange) this.onChange({ start: index, length: 1, kind: 'ascii' });
                    this._select(Math.min(this.data.length - 1, index + 1), 'ascii');
                };

                input.addEventListener('keydown', (ev) => {
                    if (ev.key === 'Enter') {
                        ev.preventDefault();
                        finish(true);
                    } else if (ev.key === 'Escape') {
                        ev.preventDefault();
                        finish(false);
                    }
                });
                input.addEventListener('blur', () => finish(true));

                overlay.appendChild(input);
                document.body.appendChild(overlay);
                this._overlay = overlay;
                input.focus();
                input.select();
            }

            _endOverlay() {
                if (!this._overlay) return;
                try {
                    this._overlay.remove();
                } catch (e) {
                    /* ignore */
                }
                this._overlay = null;
                if (this._root) this._root.focus();
                this._renderView();
            }

            _onKeyDown(e) {
                if (this._overlay) return;
                if (this._selIndex === null || this._selIndex === undefined) return;

                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    this._nextIndex(-1);
                    return;
                }
                if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    this._nextIndex(1);
                    return;
                }
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    this._nextIndex(-this.bytesPerRow);
                    return;
                }
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    this._nextIndex(this.bytesPerRow);
                    return;
                }

                if (this._selKind === 'ascii' && e.key && e.key.length === 1) {
                    const code = e.key.charCodeAt(0) & 0xFF;
                    if (isPrintableAscii(code)) {
                        e.preventDefault();
                        this.data[this._selIndex] = code;
                        this.markDirty(this._selIndex, 1);
                        if (this.onChange) this.onChange({ start: this._selIndex, length: 1, kind: 'ascii' });
                        this._selIndex = Math.min(this.data.length - 1, this._selIndex + 1);
                        this._renderView();
                    }
                }

                if (this._selKind === 'hex' && e.key && e.key.length === 1) {
                    const ch = e.key.toUpperCase();
                    if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F') {
                        e.preventDefault();

                        const nib = parseInt(ch, 16) & 0xF;
                        let which = (this._selNibble === 0 || this._selNibble === 1) ? this._selNibble : 0;

                        const oldByte = this.data[this._selIndex] & 0xFF;
                        let newByte = oldByte;
                        if (which === 0) {
                            newByte = ((nib << 4) | (oldByte & 0x0F)) & 0xFF;
                        } else {
                            newByte = ((oldByte & 0xF0) | nib) & 0xFF;
                        }
                        this.data[this._selIndex] = newByte;
                        this.markDirty(this._selIndex, 1);
                        if (this.onChange) this.onChange({ start: this._selIndex, length: 1, kind: 'hex' });

                        /* advance to next nibble */
                        if (which === 0) {
                            this._selNibble = 1;
                        } else {
                            this._selNibble = 0;
                            this._selIndex = Math.min(this.data.length - 1, this._selIndex + 1);
                        }
                        this._renderView();
                    }
                }
            }
        }

        function decodeApIdr(idr) {
            /* Matches firmware parsing in swd_apscan_test() and ADIv5 APIDR layout.
             * - REV:    bits 27:24
             * - JEP106: bits 26:17 (10-bit designer)
             * - CLASS:  bits 16:13
             * - VAR:    bits 7:4
             * - TYPE:   bits 3:0
             */
            const rev = (idr >>> 24) & 0x0F;
            const designer = (idr >>> 17) & 0x3FF;
            const ap_class = (idr >>> 13) & 0x0F;
            const variant = (idr >>> 4) & 0x0F;
            const type = (idr >>> 0) & 0x0F;
            return { rev, designer, ap_class, variant, type };
        }

        function apTypeName(info) {
            if (!info) return 'unknown';
            if (info.ap_class === 0x08) {
                if (info.type === 0x01) return 'MEM-AP (AHB)';
                if (info.type === 0x02) return 'MEM-AP (APB)';
                if (info.type === 0x04) return 'MEM-AP (AXI)';
                return `MEM-AP (type=${info.type})`;
            }
            return `class=0x${info.ap_class.toString(16)} type=0x${info.type.toString(16)}`;
        }

        class Swd {
            constructor(esp, logger) {
                this.esp = esp;
                this.log = logger || (() => {});
                this.memAp = null;
                this.lastIoMask = null;
                this.lastVerbose = false;
            }

            _expectOkStatus(rsp, what) {
                if (!rsp) throw new Error(`${what}: no response`);
                if (rsp.status !== SWD_UART_STATUS_OK) {
                    throw new Error(`${what}: status=${rsp.status}`);
                }
            }

            _checkAckOrRetry(ack) {
                if (ack === 1) return { ok: true, retry: false };
                if (ack === 2) return { ok: false, retry: true };
                if (ack === 4) return { ok: false, retry: false, fault: true };
                if (ack === 8) throw new Error('SWD parity mismatch');
                throw new Error(`SWD bad ACK=${ack}`);
            }

            async transfer(ap, write, a23, value = 0) {
                const args = new Uint8Array(8);
                args[0] = ap ? 1 : 0;
                args[1] = write ? 1 : 0;
                args[2] = a23 & 0x03;
                args[3] = 0;
                writeU32LE(args, 4, value >>> 0);
                const rsp = await this.esp.swdRequest(SWD_UART_OP_TRANSFER, args, { timeoutMs: 1500 });
                this._expectOkStatus(rsp, `transfer(ap=${ap ? 1 : 0},write=${write ? 1 : 0},a23=${a23})`);
                const outVal = (rsp.data && rsp.data.length >= 4) ? readU32LE(rsp.data, 0) : 0;
                return { ack: rsp.ack, value: outVal >>> 0, rsp };
            }

            async transferRaw(ap, write, a23, value = 0) {
                const args = new Uint8Array(8);
                args[0] = ap ? 1 : 0;
                args[1] = write ? 1 : 0;
                args[2] = a23 & 0x03;
                args[3] = 0;
                writeU32LE(args, 4, value >>> 0);
                const rsp = await this.esp.swdRequest(SWD_UART_OP_TRANSFER, args, { timeoutMs: 1500 });
                const outVal = (rsp && rsp.data && rsp.data.length >= 4) ? readU32LE(rsp.data, 0) : 0;
                return { ack: rsp ? rsp.ack : 0, value: outVal >>> 0, rsp };
            }

            async dpRead(a23) {
                for (let attempt = 0; attempt < 32; attempt++) {
                    const t = await this.transfer(false, false, a23, 0);
                    const ar = this._checkAckOrRetry(t.ack);
                    if (ar.retry) {
                        await new Promise(r => setTimeout(r, 10));
                        continue;
                    }
                    if (ar.fault) {
                        throw new Error('SWD FAULT');
                    }
                    return t.value >>> 0;
                }
                throw new Error('dpRead: too many WAIT retries');
            }

            async dpWrite(a23, value) {
                for (let attempt = 0; attempt < 32; attempt++) {
                    const t = await this.transfer(false, true, a23, value >>> 0);
                    const ar = this._checkAckOrRetry(t.ack);
                    if (ar.retry) {
                        await new Promise(r => setTimeout(r, 10));
                        continue;
                    }
                    if (ar.fault) {
                        throw new Error('SWD FAULT');
                    }
                    return true;
                }
                throw new Error('dpWrite: too many WAIT retries');
            }

            async clearStickyErrors() {
                /* ABORT bits: clear STKCMP/STKERR/WDERR/ORUNERR (best-effort) */
                try {
                    await this.dpWrite(DP_A23_ABORT, 0x1E);
                } catch (e) {
                    /* ignore */
                }
            }

            async ensurePowerUp(timeoutMs = 800) {
                /* Mirrors Flipper app swd_ensure_powerup():
                 * request debug + system power-up and wait for ACKs.
                 * Without this, a cold target may return APIDR/APBASE as 0.
                 */
                /* DP CTRL/STAT is a banked DP register (A[3:2]=0b01).
                 * If firmware previously selected a different DP bank (e.g. to read TARGETID),
                 * reading/writing A[3:2]=0b01 here may hit the wrong register.
                 * Force SELECT=0 so DPBANKSEL=0 and we really access CTRL/STAT.
                 *
                 * Note: writing DP SELECT from the host is safe in this firmware; it explicitly
                 * invalidates/updates the cached SELECT value.
                 */
                try {
                    await this.dpWrite(DP_A23_SELECT, 0);
                } catch (e) {
                    /* ignore and keep trying below */
                }

                const start = performance.now();
                let last = 0;

                while (performance.now() - start < timeoutMs) {
                    last = await this.dpRead(DP_A23_CTRLSTAT);

                    const want = (CSYSPWRUPREQ | CDBGPWRUPREQ) >>> 0;
                    const haveReq = (last & want) === want;
                    const haveAck = ((last & (CSYSPWRUPACK | CDBGPWRUPACK)) === (CSYSPWRUPACK | CDBGPWRUPACK));

                    if (!haveReq) {
                        const v = (last | want) >>> 0;
                        await this.dpWrite(DP_A23_CTRLSTAT, v);
                        await new Promise(r => setTimeout(r, 20));
                        continue;
                    }

                    if (haveAck) {
                        return { ok: true, ctrlstat: last >>> 0 };
                    }

                    await new Promise(r => setTimeout(r, 20));
                }

                return { ok: false, ctrlstat: last >>> 0 };
            }

            async postDetectInit(opts = {}) {
                const timeoutMs = (opts && opts.timeoutMs) ? (opts.timeoutMs | 0) : 1200;
                const trace = !!(opts && opts.trace);
                const allowRecover = (opts && opts.allowRecover !== undefined) ? !!opts.allowRecover : true;

                const tryOnce = async () => {
                    const pu = await this.ensurePowerUp(timeoutMs);
                    this._trace(trace, `DP power-up: ok=${pu.ok ? 1 : 0} CTRL/STAT=${u32ToHex(pu.ctrlstat)}`);
                    await this.clearStickyErrors();
                    await this.flushRdbuff();
                    return pu;
                };

                try {
                    return await tryOnce();
                } catch (e) {
                    const msg = (e && e.message) ? e.message : String(e);
                    if (allowRecover && msg.includes('SWD bad ACK=7')) {
                        /* Link looks unstable immediately after detect. Re-run detect once and retry.
                         * IMPORTANT: avoid recursion (recoverLink() normally runs postDetectInit()).
                         */
                        await this.recoverLink('post-detect init: bad ACK=7', { skipPostInit: true });
                        return await tryOnce();
                    }
                    throw e;
                }
            }

            async flushRdbuff() {
                /* If a posted AP read completed but the subsequent DP RDBUFF read failed,
                 * a stale value can remain pending and shift later reads. Drain it best-effort.
                 */
                try {
                    await this.transferRaw(false, false, DP_A23_RDBUFF, 0);
                    await this.transferRaw(false, false, DP_A23_RDBUFF, 0);
                } catch (e) {
                    /* ignore */
                }
            }

            ackName(ack) {
                if (ack === 1) return 'OK';
                if (ack === 2) return 'WAIT';
                if (ack === 4) return 'FAULT';
                if (ack === 8) return 'PARITY';
                return `BAD(${ack})`;
            }

            async dpDebugOnce() {
                const lines = [];

                const dpidr = await this.transferRaw(false, false, DP_A23_ABORT, 0);
                lines.push(`DP DPIDR/IDCODE: ack=${this.ackName(dpidr.ack)} value=${u32ToHex(dpidr.value)}`);

                const ctrl0 = await this.transferRaw(false, false, DP_A23_CTRLSTAT, 0);
                lines.push(`DP CTRL/STAT:   ack=${this.ackName(ctrl0.ack)} value=${u32ToHex(ctrl0.value)}`);

                /* On cold targets, AP reads can return 0 until power-up is requested/acked. */
                try {
                    const pu = await this.ensurePowerUp(800);
                    lines.push(`DP POWERUP:     ok=${pu.ok ? 1 : 0} CTRL/STAT=${u32ToHex(pu.ctrlstat)}`);
                } catch (e) {
                    lines.push(`DP POWERUP:     ERROR: ${e.message}`);
                }

                const abort = await this.transferRaw(false, true, DP_A23_ABORT, 0x1E);
                lines.push(`DP ABORT(0x1E): ack=${this.ackName(abort.ack)} (firmware may force OK)`);

                const ctrl1 = await this.transferRaw(false, false, DP_A23_CTRLSTAT, 0);
                lines.push(`DP CTRL/STAT:   ack=${this.ackName(ctrl1.ack)} value=${u32ToHex(ctrl1.value)} (banked)`);

                /* Do not write DP SELECT here.
                 * The firmware caches SELECT and may skip rewriting it; if the host changes SELECT behind its back,
                 * subsequent AP reads can silently access the wrong AP/Bank and return zeros with ACK=OK.
                 */

                /* Use the same safe AP helpers (SELECT+RDBUFF handling) for debug probing. */
                try {
                    const idr0 = await this.apRead(0, AP_IDR, true);
                    lines.push(`AP0 IDR:         ${u32ToHex(idr0)} (${apTypeName(decodeApIdr(idr0))})`);
                } catch (e) {
                    lines.push(`AP0 IDR:         ERROR: ${e.message}`);
                }
                try {
                    const base0 = await this.apRead(0, AP_BASE, true);
                    lines.push(`AP0 BASE:        ${u32ToHex(base0)}`);
                } catch (e) {
                    lines.push(`AP0 BASE:        ERROR: ${e.message}`);
                }

                return lines;
            }

            async detectPins(ioMask, verboseLogs = false) {
                this.lastIoMask = ioMask >>> 0;
                this.lastVerbose = !!verboseLogs;
                const args = new Uint8Array(4);
                writeU32LE(args, 0, ioMask >>> 0);
                const flags = verboseLogs ? SWD_UART_FLAG_VERBOSE_LOG : 0;
                const rsp = await this.esp.swdRequest(SWD_UART_OP_DETECT_PINS, args, { flags, timeoutMs: 15000 });
                this._expectOkStatus(rsp, 'detectPins');
                if (!rsp.data || rsp.data.length < 12) {
                    throw new Error('detectPins: short response data');
                }

                const det = {
                    swdio_gpio: rsp.swdio_gpio,
                    swclk_gpio: rsp.swclk_gpio,
                    dpidr: readU32LE(rsp.data, 0),
                    targetid: readU32LE(rsp.data, 4),
                    dpidr_ok: rsp.data[8] ? true : false,
                    targetid_ok: rsp.data[9] ? true : false,
                    detected_device: rsp.data[10] ? true : false
                };

                return det;
            }

            async recoverLink(reason = '', opts = {}) {
                if (this.lastIoMask === null || this.lastIoMask === undefined) {
                    throw new Error('recoverLink: no previous ioMask');
                }
                const msg = reason ? ` (${reason})` : '';
                this.log(`SWD link recovery: re-detecting pins${msg}...`, 'info');
                const det = await this.detectPins(this.lastIoMask, this.lastVerbose);
                this.log(`SWD link recovery: DPIDR=${u32ToHex(det.dpidr)} ok=${det.dpidr_ok ? 1 : 0}`, 'info');
                const skipPostInit = !!(opts && opts.skipPostInit);
                if (!skipPostInit) {
                    try {
                        await this.postDetectInit({ timeoutMs: 1200, allowRecover: false });
                    } catch (e) {
                        /* ignore */
                    }
                }
                return det;
            }

            _trace(enabled, message) {
                if (!enabled) return;
                if (this.log) this.log(message, 'info');
            }

            async deinit() {
                const rsp = await this.esp.swdRequest(SWD_UART_OP_DEINIT, new Uint8Array(0), { timeoutMs: 1000 });
                this._expectOkStatus(rsp, 'deinit');
                this.memAp = null;
                return true;
            }

            async apRead(ap, apOff, single = false) {
                const args = new Uint8Array(4);
                args[0] = ap & 0xFF;
                args[1] = apOff & 0xFF;
                args[2] = 0;
                args[3] = 0;

                const op = single ? SWD_UART_OP_AP_READ_SINGLE : SWD_UART_OP_AP_READ;

                for (let attempt = 0; attempt < 12; attempt++) {
                    const rsp = await this.esp.swdRequest(op, args, { timeoutMs: 1500 });
                    this._expectOkStatus(rsp, `apRead(ap=${ap},off=0x${apOff.toString(16)})`);
                    let ar;
                    try {
                        ar = this._checkAckOrRetry(rsp.ack);
                    } catch (e) {
                        const m = (e && e.message) ? e.message : String(e);
                        if (m.includes('SWD bad ACK=7') && attempt < 2) {
                            await this.recoverLink('bad ACK=7 during apRead');
                            await this.flushRdbuff();
                            await new Promise(r => setTimeout(r, 20));
                            continue;
                        }
                        throw e;
                    }
                    if (ar.retry) {
                        await new Promise(r => setTimeout(r, 10));
                        continue;
                    }
                    if (ar.fault) {
                        if (attempt < 2) {
                            await this.clearStickyErrors();
                            await new Promise(r => setTimeout(r, 10));
                            continue;
                        }
                        throw new Error('SWD FAULT');
                    }
                    if (!rsp.data || rsp.data.length < 4) {
                        throw new Error('apRead: short data');
                    }
                    return readU32LE(rsp.data, 0);
                }
                throw new Error('apRead: too many retries');
            }

            async apReadStrict(ap, apOff, single = false) {
                /* C-like semantics: do not attempt link recovery here.
                 * Let the caller decide whether to restart a larger operation.
                 */
                const args = new Uint8Array(4);
                args[0] = ap & 0xFF;
                args[1] = apOff & 0xFF;
                args[2] = 0;
                args[3] = 0;

                const op = single ? SWD_UART_OP_AP_READ_SINGLE : SWD_UART_OP_AP_READ;

                for (let attempt = 0; attempt < 64; attempt++) {
                    const rsp = await this.esp.swdRequest(op, args, { timeoutMs: 1500 });
                    this._expectOkStatus(rsp, `apReadStrict(ap=${ap},off=0x${apOff.toString(16)})`);

                    if (rsp.ack === 1) {
                        if (!rsp.data || rsp.data.length < 4) {
                            throw new Error('apReadStrict: short data');
                        }
                        return readU32LE(rsp.data, 0) >>> 0;
                    }

                    if (rsp.ack === 2) {
                        await new Promise(r => setTimeout(r, 10));
                        continue;
                    }

                    if (rsp.ack === 8) {
                        throw new Error('SWD parity mismatch');
                    }

                    /* FAULT, BAD(7), etc -> fail fast */
                    throw new Error(`SWD bad ACK=${rsp.ack}`);
                }

                throw new Error('apReadStrict: too many WAIT retries');
            }

            async apWrite(ap, apOff, value) {
                const args = new Uint8Array(8);
                args[0] = ap & 0xFF;
                args[1] = apOff & 0xFF;
                args[2] = 0;
                args[3] = 0;
                writeU32LE(args, 4, value >>> 0);

                for (let attempt = 0; attempt < 12; attempt++) {
                    const rsp = await this.esp.swdRequest(SWD_UART_OP_AP_WRITE, args, { timeoutMs: 1500 });
                    this._expectOkStatus(rsp, `apWrite(ap=${ap},off=0x${apOff.toString(16)})`);
                    let ar;
                    try {
                        ar = this._checkAckOrRetry(rsp.ack);
                    } catch (e) {
                        const m = (e && e.message) ? e.message : String(e);
                        if (m.includes('SWD bad ACK=7') && attempt < 2) {
                            await this.recoverLink('bad ACK=7 during apWrite');
                            await this.flushRdbuff();
                            await new Promise(r => setTimeout(r, 20));
                            continue;
                        }
                        throw e;
                    }
                    if (ar.retry) {
                        await new Promise(r => setTimeout(r, 10));
                        continue;
                    }
                    if (ar.fault) {
                        if (attempt < 2) {
                            await this.clearStickyErrors();
                            await new Promise(r => setTimeout(r, 10));
                            continue;
                        }
                        throw new Error('SWD FAULT');
                    }
                    return true;
                }
                throw new Error('apWrite: too many WAIT retries');
            }

            async apWriteStrict(ap, apOff, value) {
                const args = new Uint8Array(8);
                args[0] = ap & 0xFF;
                args[1] = apOff & 0xFF;
                args[2] = 0;
                args[3] = 0;
                writeU32LE(args, 4, value >>> 0);

                for (let attempt = 0; attempt < 64; attempt++) {
                    const rsp = await this.esp.swdRequest(SWD_UART_OP_AP_WRITE, args, { timeoutMs: 1500 });
                    this._expectOkStatus(rsp, `apWriteStrict(ap=${ap},off=0x${apOff.toString(16)})`);

                    if (rsp.ack === 1) {
                        return true;
                    }
                    if (rsp.ack === 2) {
                        await new Promise(r => setTimeout(r, 10));
                        continue;
                    }
                    if (rsp.ack === 8) {
                        throw new Error('SWD parity mismatch');
                    }
                    throw new Error(`SWD bad ACK=${rsp.ack}`);
                }

                throw new Error('apWriteStrict: too many WAIT retries');
            }

            async scanAps(maxAps = 16, opts = {}) {
                const fullScan = !!(opts && opts.fullScan);
                const trace = !!(opts && opts.trace);

                /* Best-effort: clear sticky flags before scanning. */
                await this.clearStickyErrors();

                /* Cold start often needs explicit power-up request before AP reads. */
                try {
                    const pu = await this.ensurePowerUp(800);
                    this._trace(trace, `DP power-up: ok=${pu.ok ? 1 : 0} CTRL/STAT=${u32ToHex(pu.ctrlstat)}`);
                } catch (e) {
                    this._trace(trace, `DP power-up: ERROR: ${e.message}`);
                }

                const aps = [];
                let badAckRecoveries = 0;
                let consecutiveFailures = 0;
                let consecutiveEmptyIdr = 0;
                for (let ap = 0; ap < maxAps; ap++) {
                    this._trace(trace, `AP scan: probing AP${ap}...`);
                    let idr = 0;
                    try {
                        idr = await this.apReadStrict(ap, AP_IDR, true);
                        consecutiveFailures = 0;
                        this._trace(trace, `AP${ap}: IDR=${u32ToHex(idr)}`);
                    } catch (e) {
                        const msg = (e && e.message) ? e.message : String(e);
                        if (msg.includes('SWD bad ACK=7')) {
                            /* If the line is unstable (invalid SWD ACK), don't loop forever.
                             * Try a bounded number of recoveries, then abort the scan.
                             */
                            if (badAckRecoveries >= 2) {
                                throw new Error('AP scan aborted: repeated SWD bad ACK=7 (link unstable)');
                            }
                            badAckRecoveries++;
                            this._trace(trace, `AP${ap}: bad ACK=7, attempting link recovery (${badAckRecoveries}/2) then retry...`);
                            await this.recoverLink('bad ACK=7 during scan');
                            await new Promise(r => setTimeout(r, 80));
                            /* retry same AP index */
                            ap--;
                            continue;
                        }
                        consecutiveFailures++;
                        this._trace(trace, `AP${ap}: read failed (${msg}), consecutiveFailures=${consecutiveFailures}`);
                        /* If nothing was found yet, bail out early to avoid destabilizing the link by probing
                         * many non-existent APSEL values.
                         */
                        if (!fullScan && aps.length === 0 && consecutiveFailures >= 4) {
                            throw e;
                        }
                        /* If we already found at least one AP, stop after a few consecutive failures. */
                        if (!fullScan && aps.length > 0 && consecutiveFailures >= 3) {
                            break;
                        }
                        continue;
                    }
                    if (idr === 0 || idr === 0xFFFFFFFF) {
                        this._trace(trace, `AP${ap}: IDR ignored (${u32ToHex(idr)})`);

                        if (!fullScan && aps.length > 0)
                        {
                            consecutiveEmptyIdr++;
                            if (consecutiveEmptyIdr >= 8)
                            {
                                this._trace(trace, `AP scan: stopping after ${consecutiveEmptyIdr} empty IDRs`);
                                break;
                            }
                        }
                        continue;
                    }

                    consecutiveEmptyIdr = 0;
                    const info = decodeApIdr(idr);

                    let base = null;
                    try {
                        base = await this.apReadStrict(ap, AP_BASE, true);
                        this._trace(trace, `AP${ap}: BASE=${u32ToHex(base)}`);
                    } catch (e) {
                        const msg = (e && e.message) ? e.message : String(e);
                        this._trace(trace, `AP${ap}: BASE read failed (${msg})`);
                        base = null;
                    }
                    const entry = { ap, idr, info, base };
                    aps.push(entry);
                }

                const mem = aps.find(a => a.info && a.info.ap_class === 0x08) || null;
                this.memAp = mem ? mem.ap : null;
                return { aps, memAp: this.memAp };
            }

            async memRead32Via(ap, address) {
                const csw = 0x23000002;
                const base = address >>> 0;

                for (let attempt = 0; attempt < 3; attempt++) {
                    try {
                        await this.apWriteStrict(ap, MEMAP_CSW, csw);
                        await this.apWriteStrict(ap, MEMAP_TAR, base);
                        /* dummy read */
                        await this.apReadStrict(ap, MEMAP_DRW, true);
                        const v = await this.apReadStrict(ap, MEMAP_DRW, true);
                        return v >>> 0;
                    } catch (e) {
                        const msg = (e && e.message) ? e.message : String(e);
                        if (attempt < 2) {
                            await this.recoverLink(`memRead32Via restart (${msg})`);
                            await this.flushRdbuff();
                            await new Promise(r => setTimeout(r, 20));
                            continue;
                        }
                        throw e;
                    }
                }

                throw new Error('memRead32Via: unreachable');
            }

            async memReadBlock32Via(ap, address, words) {
                const csw = 0x23000012;
                const base = address >>> 0;
                const count = words >>> 0;

                /* C-like behavior: if anything goes wrong mid-block, restart the whole block.
                 * This avoids partial results / word shifts after recover.
                 */
                for (let attempt = 0; attempt < 3; attempt++) {
                    const temp = [];
                    try {
                        /* Some targets/peripherals effectively behave like DRW returns the first word
                         * immediately (no observable dummy read needed), while others require the classic
                         * MEM-AP priming read.
                         *
                         * To avoid the common "first word skipped" symptom, take a reference word0 via
                         * non-incrementing single read, then decide whether the first DRW read already
                         * equals word0.
                         */
                        let ref0 = null;
                        try {
                            ref0 = await this.memRead32Via(ap, base);
                        } catch (e) {
                            ref0 = null;
                        }

                        await this.apWriteStrict(ap, MEMAP_CSW, csw);
                        await this.apWriteStrict(ap, MEMAP_TAR, base);

                        if (count === 0) return [];

                        const r0 = await this.apReadStrict(ap, MEMAP_DRW, true);
                        if (count === 1) {
                            if (ref0 !== null && (r0 >>> 0) === (ref0 >>> 0)) {
                                return [r0 >>> 0];
                            }
                            const r1 = await this.apReadStrict(ap, MEMAP_DRW, true);
                            return [r1 >>> 0];
                        }

                        const r1 = await this.apReadStrict(ap, MEMAP_DRW, true);

                        const r0IsWord0 = (ref0 !== null) && ((r0 >>> 0) === (ref0 >>> 0));
                        if (r0IsWord0) {
                            temp.push(r0 >>> 0);
                            temp.push(r1 >>> 0);
                            for (let i = 2; i < count; i++) {
                                const v = await this.apReadStrict(ap, MEMAP_DRW, true);
                                temp.push(v >>> 0);
                            }
                        } else {
                            /* Treat r0 as dummy/priming, and r1 as word0 */
                            temp.push(r1 >>> 0);
                            for (let i = 1; i < count; i++) {
                                const v = await this.apReadStrict(ap, MEMAP_DRW, true);
                                temp.push(v >>> 0);
                            }
                        }
                        return temp;
                    } catch (e) {
                        const msg = (e && e.message) ? e.message : String(e);
                        if (attempt < 2) {
                            await this.recoverLink(`memReadBlock32Via restart (${msg})`);
                            await this.flushRdbuff();
                            await new Promise(r => setTimeout(r, 30));
                            continue;
                        }
                        throw e;
                    }
                }

                throw new Error('memReadBlock32Via: unreachable');
            }

            async memWriteBlock32Via(ap, address, words) {
                const csw = 0x23000012;
                await this.apWrite(ap, MEMAP_CSW, csw);
                await this.apWrite(ap, MEMAP_TAR, address >>> 0);
                for (let i = 0; i < words.length; i++) {
                    await this.apWrite(ap, MEMAP_DRW, (words[i] >>> 0));
                }
                return true;
            }

            async memWriteBlock16Via(ap, address, halfwords) {
                const csw = 0x23000011;
                const addr = address >>> 0;
                if ((addr & 1) !== 0) throw new Error('memWriteBlock16Via: unaligned address');
                await this.apWrite(ap, MEMAP_CSW, csw);
                await this.apWrite(ap, MEMAP_TAR, addr);
                for (let i = 0; i < halfwords.length; i++) {
                    await this.apWrite(ap, MEMAP_DRW, (halfwords[i] & 0xFFFF) >>> 0);
                }
                return true;
            }

            async memWriteBlock8Via(ap, address, bytes) {
                const csw = 0x23000010;
                const addr = address >>> 0;
                await this.apWrite(ap, MEMAP_CSW, csw);
                await this.apWrite(ap, MEMAP_TAR, addr);
                for (let i = 0; i < bytes.length; i++) {
                    await this.apWrite(ap, MEMAP_DRW, (bytes[i] & 0xFF) >>> 0);
                }
                return true;
            }

            async memWrite32Via(ap, address, value) {
                const csw = 0x23000002;
                const base = address >>> 0;

                for (let attempt = 0; attempt < 3; attempt++) {
                    try {
                        await this.apWriteStrict(ap, MEMAP_CSW, csw);
                        await this.apWriteStrict(ap, MEMAP_TAR, base);
                        await this.apWriteStrict(ap, MEMAP_DRW, value >>> 0);
                        return true;
                    } catch (e) {
                        const msg = (e && e.message) ? e.message : String(e);
                        if (attempt < 2) {
                            await this.recoverLink(`memWrite32Via restart (${msg})`);
                            await this.flushRdbuff();
                            await new Promise(r => setTimeout(r, 20));
                            continue;
                        }
                        throw e;
                    }
                }

                throw new Error('memWrite32Via: unreachable');
            }

            async coreHaltVia(ap) {
                const dhcsr = (SCS_DHCSR_KEY | SCS_DHCSR_C_HALT | SCS_DHCSR_C_DEBUGEN) >>> 0;
                await this.memWrite32Via(ap, SCS_DHCSR, dhcsr);
                const v = await this.memRead32Via(ap, SCS_DHCSR);
                return { dhcsr: v >>> 0, halted: !!(v & SCS_DHCSR_S_HALT) };
            }

            async coreContinueVia(ap) {
                const v = await this.memRead32Via(ap, SCS_DHCSR);
                if (!(v & SCS_DHCSR_S_HALT)) {
                    return { dhcsr: v >>> 0, continued: false, reason: 'not halted' };
                }
                await this.memWrite32Via(ap, SCS_DHCSR, SCS_DHCSR_KEY);
                const v2 = await this.memRead32Via(ap, SCS_DHCSR);
                return { dhcsr: v2 >>> 0, continued: true };
            }

            async coreStepVia(ap) {
                const v = await this.memRead32Via(ap, SCS_DHCSR);
                if (!(v & SCS_DHCSR_S_HALT)) {
                    return { dhcsr: v >>> 0, stepped: false, reason: 'not halted' };
                }
                const dhcsr = (SCS_DHCSR_KEY | SCS_DHCSR_C_STEP | SCS_DHCSR_C_MASKINTS | SCS_DHCSR_C_DEBUGEN) >>> 0;
                await this.memWrite32Via(ap, SCS_DHCSR, dhcsr);
                const v2 = await this.memRead32Via(ap, SCS_DHCSR);
                return { dhcsr: v2 >>> 0, stepped: true };
            }

            async coreCpuidVia(ap) {
                const v = await this.memRead32Via(ap, SCS_CPUID);
                return v >>> 0;
            }

            async _coreWaitRegReadyVia(ap, timeoutMs = 200) {
                const start = performance.now();
                while (performance.now() - start < timeoutMs) {
                    const dhcsr = await this.memRead32Via(ap, SCS_DHCSR);
                    if (dhcsr & SCS_DHCSR_S_REGRDY) return true;
                    await new Promise(r => setTimeout(r, 5));
                }
                return false;
            }

            async coreRegReadVia(ap, regsel) {
                await this.memWrite32Via(ap, SCS_DCRSR, (SCS_DCRSR_RD | (regsel & 0xFFFF)) >>> 0);
                await this._coreWaitRegReadyVia(ap, 250);
                const v = await this.memRead32Via(ap, SCS_DCRDR);
                return v >>> 0;
            }

            async coreRegWriteVia(ap, regsel, value) {
                await this.memWrite32Via(ap, SCS_DCRDR, value >>> 0);
                await this.memWrite32Via(ap, SCS_DCRSR, (SCS_DCRSR_WR | (regsel & 0xFFFF)) >>> 0);
                await this._coreWaitRegReadyVia(ap, 250);
                return true;
            }

            async adiGetPidrVia(ap, base) {
                const b = base >>> 0;
                const pidrs = [];
                for (const off of CS_PIDR_OFFS) {
                    pidrs.push(await this.memRead32Via(ap, (b + off) >>> 0));
                }

                const designer = ((((pidrs[4] & 0x0F) << 7) | ((pidrs[2] & 0x07) << 4) | ((pidrs[1] >> 4) & 0x0F)) & 0x3FF) >>> 0;
                const part = (((pidrs[0] & 0xFF) | ((pidrs[1] & 0x0F) << 8)) & 0xFFFF) >>> 0;
                const revand = (((pidrs[3] >> 4) & 0x0F) & 0xFF) >>> 0;
                const cmod = ((pidrs[3] & 0x0F) & 0xFF) >>> 0;
                const revision = (((pidrs[2] >> 4) & 0x0F) & 0xFF) >>> 0;
                const size = (((pidrs[2] >> 4) & 0x0F) & 0xFF) >>> 0;

                return { designer, part, revision, cmod, revand, size };
            }

            async adiGetClassVia(ap, base) {
                const b = base >>> 0;
                const cidrs = [];
                for (const off of CS_CIDR_OFFS) {
                    cidrs.push(await this.memRead32Via(ap, (b + off) >>> 0));
                }

                if ((cidrs[0] & 0xFF) !== 0x0D) return null;
                if ((cidrs[1] & 0x0F) !== 0x00) return null;
                if ((cidrs[2] & 0xFF) !== 0x05) return null;
                if ((cidrs[3] & 0xFF) !== 0xB1) return null;

                return ((cidrs[1] >> 4) & 0x0F) >>> 0;
            }

            async adiRomtableEntryCountVia(ap, base) {
                const b = base >>> 0;
                let count = 0;
                for (let pos = 0; pos < 960; pos++) {
                    const entry = await this.memRead32Via(ap, (b + (pos * 4)) >>> 0);
                    if ((entry & 1) === 0) break;
                    if (entry & 0x00000FFC) break;
                    count++;
                }
                return count >>> 0;
            }

            async adiRomtableGetVia(ap, base, pos) {
                const entry = await this.memRead32Via(ap, (base + ((pos >>> 0) * 4)) >>> 0);
                return (base + (entry & 0xFFFFF000)) >>> 0;
            }

            async memRead32(address) {
                if (this.memAp === null || this.memAp === undefined) {
                    throw new Error('No MEM-AP selected');
                }
                const ap = this.memAp;
                const csw = 0x23000002;
                await this.apWrite(ap, MEMAP_CSW, csw);
                await this.apWrite(ap, MEMAP_TAR, address >>> 0);
                const v = await this.apRead(ap, MEMAP_DRW, false);
                return v >>> 0;
            }

            async memReadBlock32(address, words) {
                if (this.memAp === null || this.memAp === undefined) {
                    throw new Error('No MEM-AP selected');
                }
                return await this.memReadBlock32Via(this.memAp, address >>> 0, words >>> 0);
            }
        }

        /* ============= SWD Test Functions ============= */

        function calculateMaskFromCheckboxes(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return 0;
            
            let mask = 0;
            const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
            for (const checkbox of checkboxes) {
                const bit = parseInt(checkbox.value, 10);
                mask = (mask | (1 << bit)) >>> 0;
            }
            return mask;
        }

        async function runSWDTest() {
            if (!espSerial || !espSerial.port) {
                logToConsole('Not connected', 'error');
                return;
            }

            const btnDetect = document.getElementById('btnRunSWDTest');
            const scanBtn = document.getElementById('btnScanAps');
            const dpBtn = document.getElementById('btnDpDebug');

            const setDetectBtn = (active) => {
                if (!btnDetect) return;
                if (active) {
                    btnDetect.textContent = 'Stop';
                    btnDetect.style.background = '#ef4444';
                } else {
                    btnDetect.textContent = 'Detect device';
                    btnDetect.style.background = '#10b981';
                }
            };

            const resetSwdUi = () => {
                const pinsEl = document.getElementById('detectedPins');
                const idsEl = document.getElementById('detectedIds');
                const apTabsEl = document.getElementById('apTabs');
                const apPanelEl = document.getElementById('apPanel');
                if (pinsEl) pinsEl.textContent = '-';
                if (idsEl) idsEl.textContent = '-';
                if (apTabsEl) apTabsEl.innerHTML = '';
                if (apPanelEl) apPanelEl.textContent = '(not scanned)';

                scannedAps = [];
                activeAp = null;
                apHexEditors.clear();
                apSubTabState.clear();

                /* New target detection should not reuse prior CoreSight scan trees. */
                coresightTreeCache.clear();
            };

            /* Toggle behavior: if cyclic detection is running, stop it (no logs). */
            if (detectLoopActive) {
                detectLoopActive = false;
                detectLoopToken++;
                setDetectBtn(false);
                return;
            }

            /* Best-effort: prime audio from the user gesture. */
            primeTadaaAudio();

            const detectStartMs = performance.now();

            resetSwdUi();
            if (scanBtn) scanBtn.disabled = true;
            if (dpBtn) dpBtn.disabled = true;

            detectLoopActive = true;
            const myToken = ++detectLoopToken;
            setDetectBtn(true);

            const sleep = (ms) => new Promise(r => setTimeout(r, ms | 0));

            try {
                const ioMask = calculateMaskFromCheckboxes('ioGpioCheckboxes');
                const verbose = !!(document.getElementById('chkVerboseSwd') && document.getElementById('chkVerboseSwd').checked);

                if (!swd) {
                    swd = new Swd(espSerial, logToConsole);
                }

                while (detectLoopActive && myToken === detectLoopToken) {
                    let det = null;
                    try {
                        /* Quiet cycling: don't ask firmware to be verbose. */
                        det = await swd.detectPins(ioMask, false);
                    } catch (e) {
                        await sleep(250);
                        continue;
                    }

                    if (!det || !det.detected_device || !det.dpidr_ok) {
                        await sleep(250);
                        continue;
                    }

                    /* Found a device: stop cycling. */
                    detectLoopActive = false;
                    setDetectBtn(false);

                    if ((performance.now() - detectStartMs) >= 1000) {
                        playTadaa();
                    }

                    /* Optional: re-run detect once with user verbosity. */
                    try {
                        det = await swd.detectPins(ioMask, verbose);
                    } catch (e) {
                        /* keep prior det */
                    }

                    const pinsEl = document.getElementById('detectedPins');
                    const idsEl = document.getElementById('detectedIds');
                    if (pinsEl) pinsEl.textContent = `SWDIO=GPIO${det.swdio_gpio}  SWCLK=GPIO${det.swclk_gpio}`;
                    if (idsEl) {
                        const tid = det.targetid_ok ? u32ToHex(det.targetid) : '-';
                        idsEl.textContent = `${u32ToHex(det.dpidr)} / ${tid}`;
                    }

                    if (scanBtn) scanBtn.disabled = false;
                    if (dpBtn) dpBtn.disabled = false;

                    try {
                        logToConsole(`SWD Detect: io_mask=${u32ToHex(ioMask)}`, 'info');
                        logToConsole('DP power-up: requesting CSYSPWRUPREQ + CDBGPWRUPREQ...', 'info');
                        const pu = await swd.postDetectInit({ timeoutMs: 1200 });
                        logToConsole(`DP power-up: ok=${pu.ok ? 1 : 0} CTRL/STAT=${u32ToHex(pu.ctrlstat)}`, pu.ok ? 'info' : 'error');
                    } catch (e) {
                        logToConsole(`DP power-up: ERROR: ${e.message}`, 'error');
                    }

                    logToConsole('Ready: click DP Debug, then Scan APs', 'info');
                    return;
                }

                /* Stopped by user or token change: no logs. */
            } finally {
                if (myToken === detectLoopToken && !detectLoopActive) {
                    setDetectBtn(false);
                }
            }
        }

        async function dpDebug() {
            if (!swd) {
                logToConsole('SWD not initialized', 'error');
                return;
            }
            try {
                logToConsole('DP debug: running raw DP/AP probes...', 'info');
                const lines = await swd.dpDebugOnce();
                for (const l of lines) {
                    logToConsole(l, 'info');
                }
            } catch (err) {
                logToConsole(`DP debug error: ${err.message}`, 'error');
            }
        }

        async function scanAps() {
            if (!swd) {
                logToConsole('SWD not initialized', 'error');
                return;
            }

            if (scanInProgress) {
                logToConsole('AP scan already running', 'info');
                return;
            }

            try {
                scanInProgress = true;
                const scanBtn = document.getElementById('btnScanAps');
                if (scanBtn) scanBtn.disabled = true;

                const maxEl = document.getElementById('apScanMaxInput');
                const fullEl = document.getElementById('chkFullApScan');
                const verboseEl = document.getElementById('chkVerboseSwd');
                let maxAps = 32;
                if (maxEl && maxEl.value) {
                    const v = parseHexOrDec(maxEl.value);
                    if (v > 0) maxAps = v;
                }
                maxAps = Math.max(1, Math.min(256, maxAps | 0));
                const fullScan = !!(fullEl && fullEl.checked);
                const trace = !!(verboseEl && verboseEl.checked);

                logToConsole(`AP scan: reading APIDR/APBASE... (max=${maxAps}${fullScan ? ', full' : ''})`, 'info');
                const res = await swd.scanAps(maxAps, { fullScan, trace });
                scannedAps = res.aps || [];

                renderApTabs(scannedAps, res.memAp);

                if (!scannedAps.length) {
                    activeAp = null;
                    setActiveAp(null);
                    return;
                }

                const hasActive = (activeAp !== null && activeAp !== undefined) && scannedAps.some(a => a.ap === activeAp);
                if (!hasActive) {
                    activeAp = (res.memAp !== null && res.memAp !== undefined) ? res.memAp : scannedAps[0].ap;
                }
                setActiveAp(activeAp);
            } catch (err) {
                logToConsole(`AP scan error: ${err.message}`, 'error');
            } finally {
                scanInProgress = false;
                const scanBtn = document.getElementById('btnScanAps');
                if (scanBtn) scanBtn.disabled = false;
            }
        }

        async function doRead32() {
            if (!swd) return;
            try {
                const addrEl = document.getElementById('memAddrInput');
                if (!addrEl) throw new Error('No memory address input (select a MEM-AP tab)');
                lastMemAddrText = addrEl.value;
                const addr = parseHexOrDec(addrEl.value);
                if (activeAp === null || activeAp === undefined) {
                    throw new Error('No AP selected');
                }
                const apInfo = scannedAps.find(a => a.ap === activeAp);
                if (!apInfo || !apInfo.info || apInfo.info.ap_class !== 0x08) {
                    throw new Error('Selected AP is not a MEM-AP');
                }
                const v = await swd.memRead32Via(activeAp, addr);
                const valEl = document.getElementById('memWriteValueInput');
                if (valEl) {
                    valEl.value = u32ToHex(v);
                    lastMemWriteValueText = valEl.value;
                    flashInput(valEl, 420);
                }
            } catch (err) {
                logToConsole(`Read32 error: ${err.message}`, 'error');
                showToast(`Read32 failed: ${err.message}`, 'error');
            }
        }

        async function doWrite32() {
            if (!swd) return;
            try {
                const addrEl = document.getElementById('memAddrInput');
                const valEl = document.getElementById('memWriteValueInput');
                if (!addrEl || !valEl) throw new Error('No memory inputs (select a MEM-AP tab)');

                lastMemAddrText = addrEl.value;
                lastMemWriteValueText = valEl.value;

                const addr = parseHexOrDec(addrEl.value);
                const value = parseHexOrDec(valEl.value) >>> 0;

                if (activeAp === null || activeAp === undefined) {
                    throw new Error('No AP selected');
                }
                const apInfo = scannedAps.find(a => a.ap === activeAp);
                if (!apInfo || !apInfo.info || apInfo.info.ap_class !== 0x08) {
                    throw new Error('Selected AP is not a MEM-AP');
                }

                await swd.memWrite32Via(activeAp, addr, value);
            } catch (err) {
                logToConsole(`Write32 error: ${err.message}`, 'error');
                showToast(`Write32 failed: ${err.message}`, 'error');
            }
        }

        async function doReadBlock() {
            if (!swd) return;
            try {
                const addrEl = document.getElementById('memAddrInput');
                const wordsEl = document.getElementById('memWordsInput');
                const useBlkEl = document.getElementById('memUseBlockRead');
                if (!addrEl || !wordsEl) throw new Error('No memory inputs (select a MEM-AP tab)');
                lastMemAddrText = addrEl.value;
                lastMemWordsText = wordsEl.value;

                const addr = parseHexOrDec(addrEl.value);
                const words = Math.max(1, Math.min(256, parseHexOrDec(wordsEl.value) || 16));
                const useBlock = !!(useBlkEl && useBlkEl.checked);
                lastMemUseBlockRead = useBlock;
                if (activeAp === null || activeAp === undefined) {
                    throw new Error('No AP selected');
                }
                const apInfo = scannedAps.find(a => a.ap === activeAp);
                if (!apInfo || !apInfo.info || apInfo.info.ap_class !== 0x08) {
                    throw new Error('Selected AP is not a MEM-AP');
                }

                let data;
                if (useBlock) {
                    data = await swd.memReadBlock32Via(activeAp, addr, words);
                } else {
                    data = [];
                    for (let i = 0; i < words; i++) {
                        const v = await swd.memRead32Via(activeAp, (addr + (i * 4)) >>> 0);
                        data.push(v >>> 0);
                    }
                }
                const bytes = new Uint8Array(words * 4);
                for (let i = 0; i < data.length; i++) {
                    const v = data[i] >>> 0;
                    bytes[i * 4 + 0] = v & 0xFF;
                    bytes[i * 4 + 1] = (v >>> 8) & 0xFF;
                    bytes[i * 4 + 2] = (v >>> 16) & 0xFF;
                    bytes[i * 4 + 3] = (v >>> 24) & 0xFF;
                }
                const ed = apHexEditors.get(activeAp);
                if (ed) {
                    ed.setData(bytes, addr);
                }
                logToConsole(`AP${activeAp} ReadBlock @${u32ToHex(addr)} words=${words} mode=${useBlock ? 'block' : 'single'}`, 'info');
            } catch (err) {
                logToConsole(`ReadBlock error: ${err.message}`, 'error');
                showToast(`Read block failed: ${err.message}`, 'error');
            }
        }

        function renderApTabs(aps, memAp) {
            const tabsEl = document.getElementById('apTabs');
            const panelEl = document.getElementById('apPanel');
            if (!tabsEl || !panelEl) return;

            tabsEl.innerHTML = '';
            if (!aps || !aps.length) {
                panelEl.textContent = '(no APs found)';
                return;
            }

            for (const a of aps) {
                const btn = document.createElement('button');
                btn.className = 'ap-tab' + ((activeAp === a.ap) ? ' active' : '');
                btn.dataset.ap = String(a.ap);
                const info = a.info;
                const t = apTypeName(info);
                const marker = (memAp !== null && memAp !== undefined && a.ap === memAp) ? ' *' : '';
                btn.textContent = `AP${a.ap}${marker} ${t}`;
                btn.title = `${t}  IDR=${u32ToHex(a.idr)}`;
                btn.onclick = () => setActiveAp(a.ap);
                tabsEl.appendChild(btn);
            }
        }

        function setActiveAp(ap) {
            activeAp = ap;
            const tabsEl = document.getElementById('apTabs');
            const panelEl = document.getElementById('apPanel');
            if (!tabsEl || !panelEl) return;

            if (!scannedAps || !scannedAps.length) {
                panelEl.textContent = '(no APs found)';
                return;
            }

            if (ap === null || ap === undefined) {
                panelEl.textContent = '(no AP selected)';
                return;
            }

            const buttons = tabsEl.querySelectorAll('.ap-tab');
            for (const b of buttons) {
                b.classList.remove('active');
                if (b.dataset && b.dataset.ap === String(ap)) {
                    b.classList.add('active');
                }
            }

            const a = scannedAps.find(x => x.ap === ap);
            if (!a) {
                panelEl.textContent = '(AP not found in scan results - rescan)';
                return;
            }

            const info = a.info;
            const t = apTypeName(info);
            const baseStr = (a.base === null || a.base === undefined) ? '-' : u32ToHex(a.base);
            const designerStr = info ? `designer=0x${info.designer.toString(16)}` : '';

            const isMem = !!(info && info.ap_class === 0x08);

            panelEl.innerHTML = '';

            const hdr = document.createElement('div');
            hdr.textContent = `AP${a.ap}: IDR=${u32ToHex(a.idr)}  ${t}  ${designerStr}  BASE=${baseStr}`;
            panelEl.appendChild(hdr);

            const subTabsEl = document.createElement('div');
            subTabsEl.className = 'ap-subtabs';
            panelEl.appendChild(subTabsEl);

            const pages = new Map();
            const mkPage = () => {
                const p = document.createElement('div');
                p.className = 'ap-subpanel';
                p.style.display = 'none';
                return p;
            };
            const pageInfo = mkPage();
            const pageHex = mkPage();
            const pageCoresight = mkPage();
            const pageDebug = mkPage();
            pages.set('info', pageInfo);
            pages.set('hex', pageHex);
            pages.set('coresight', pageCoresight);
            pages.set('debug', pageDebug);

            panelEl.appendChild(pageInfo);
            panelEl.appendChild(pageHex);
            panelEl.appendChild(pageCoresight);
            panelEl.appendChild(pageDebug);

            let selected = apSubTabState.get(a.ap) || 'info';
            if (!isMem && selected !== 'info') selected = 'info';

            const debugSupport = { state: 'unknown', cpuid: null };
            async function probeDebugSupport() {
                if (!isMem) {
                    debugSupport.state = 'no-mem';
                    return debugSupport;
                }
                if (debugSupport.state !== 'unknown') return debugSupport;
                try {
                    const v = await swd.coreCpuidVia(a.ap);
                    debugSupport.state = 'ok';
                    debugSupport.cpuid = v >>> 0;
                } catch (e) {
                    debugSupport.state = 'fail';
                    debugSupport.cpuid = null;
                }
                return debugSupport;
            }

            const subBtnById = new Map();
            const addSubTab = (id, title, enabled = true) => {
                const btn = document.createElement('button');
                btn.className = 'ap-subtab' + ((selected === id) ? ' active' : '');
                btn.textContent = title;
                btn.disabled = !enabled;
                btn.onclick = async () => {
                    if (btn.disabled) return;
                    await selectSubTab(id);
                };
                subTabsEl.appendChild(btn);
                subBtnById.set(id, btn);
            };

            addSubTab('info', 'Info', true);
            addSubTab('hex', 'Hex dump', isMem);
            addSubTab('coresight', 'CoreSight', isMem);
            addSubTab('debug', 'Debugging', isMem);

            async function selectSubTab(id) {
                if (!isMem && id !== 'info') id = 'info';
                selected = id;
                apSubTabState.set(a.ap, id);
                for (const [k, p] of pages.entries()) {
                    p.style.display = (k === id) ? 'block' : 'none';
                }
                for (const [k, b] of subBtnById.entries()) {
                    if (k === id) b.classList.add('active');
                    else b.classList.remove('active');
                }
                if (id === 'debug') {
                    await probeDebugSupport();
                    renderDebugSupportBanner();
                }
            }

            function fmtMaybeU32(v) {
                if (v === null || v === undefined) return '-';
                return u32ToHex(v >>> 0);
            }

            const apInfoBox = document.createElement('div');
            apInfoBox.style.whiteSpace = 'pre-wrap';
            apInfoBox.style.marginTop = '8px';
            apInfoBox.style.padding = '8px';
            apInfoBox.style.border = '1px solid #374151';
            apInfoBox.style.borderRadius = '6px';
            apInfoBox.style.background = '#0b1220';
            apInfoBox.textContent = '(not loaded)';

            async function refreshApInfo() {
                const lines = [];
                lines.push(`AP${a.ap}`);
                lines.push(`APIDR: ${u32ToHex(a.idr)} (${t})`);
                if (info) {
                    lines.push(`  REV=${info.rev}  JEP106(designer)=0x${info.designer.toString(16)}  CLASS=0x${info.ap_class.toString(16)}  VAR=0x${info.variant.toString(16)}  TYPE=0x${info.type.toString(16)}`);
                }
                lines.push(`BASE:  ${baseStr}`);

                try {
                    const idrNow = await swd.apRead(a.ap, AP_IDR, true);
                    const baseNow = await swd.apRead(a.ap, AP_BASE, true);
                    let cfgNow = null;
                    try { cfgNow = await swd.apRead(a.ap, 0xF4, true); } catch (e) { cfgNow = null; }
                    lines.push('');
                    lines.push('Live AP regs:');
                    lines.push(`  IDR (0xFC):  ${u32ToHex(idrNow)}`);
                    lines.push(`  BASE(0xF8):  ${u32ToHex(baseNow)}`);
                    lines.push(`  CFG (0xF4):  ${fmtMaybeU32(cfgNow)}`);
                    if (isMem) {
                        let cswNow = null;
                        try { cswNow = await swd.apRead(a.ap, 0x00, true); } catch (e) { cswNow = null; }
                        lines.push(`  CSW (0x00):  ${fmtMaybeU32(cswNow)}`);
                    }
                } catch (e) {
                    lines.push('');
                    lines.push(`Live AP regs: read failed (${e.message})`);
                }

                apInfoBox.textContent = lines.join('\n');
            }

            const ops = document.createElement('div');
            ops.className = 'row';

            const btnRefreshInfo = document.createElement('button');
            btnRefreshInfo.textContent = 'Refresh info';
            btnRefreshInfo.onclick = async () => {
                try {
                    await refreshApInfo();
                } catch (e) {
                    apInfoBox.textContent = `Refresh failed: ${e.message}`;
                }
            };

            const regOff = document.createElement('input');
            regOff.id = 'apRegOffInput';
            regOff.value = '0xFC';
            regOff.style.width = '90px';

            const regBtn = document.createElement('button');
            regBtn.textContent = 'Read AP reg';
            regBtn.onclick = async () => {
                try {
                    const off = parseHexOrDec(regOff.value) & 0xFF;
                    const v = await swd.apRead(a.ap, off, true);
                    logToConsole(`AP${a.ap} ReadReg off=0x${off.toString(16)} => ${u32ToHex(v)}`, 'info');
                } catch (e) {
                    logToConsole(`AP${a.ap} ReadReg error: ${e.message}`, 'error');
                }
            };

            ops.appendChild(btnRefreshInfo);
            ops.appendChild(document.createTextNode('Reg off:'));
            ops.appendChild(regOff);
            ops.appendChild(regBtn);
            pageInfo.appendChild(ops);
            pageInfo.appendChild(apInfoBox);

            if (isMem) {
                /* ============ Hex dump tab ============ */
                const memHdr = document.createElement('div');
                memHdr.style.marginTop = '10px';
                memHdr.style.color = '#a3e635';
                memHdr.style.fontWeight = '700';
                memHdr.textContent = 'MEM-AP memory access';
                pageHex.appendChild(memHdr);

                const row1 = document.createElement('div');
                row1.className = 'row';
                row1.appendChild(document.createTextNode('Addr:'));

                const addr = document.createElement('input');
                addr.id = 'memAddrInput';
                addr.value = lastMemAddrText || '0xE000ED00';
                addr.style.width = '140px';

                const b32 = document.createElement('button');
                b32.id = 'btnRead32';
                b32.textContent = 'Read32';
                b32.onclick = doRead32;

                row1.appendChild(addr);
                row1.appendChild(b32);
                pageHex.appendChild(row1);

                const rowW = document.createElement('div');
                rowW.className = 'row';
                rowW.appendChild(document.createTextNode('Value:'));

                const wval = document.createElement('input');
                wval.id = 'memWriteValueInput';
                wval.value = lastMemWriteValueText || '0x00000000';
                wval.style.width = '140px';

                const bw = document.createElement('button');
                bw.id = 'btnWrite32';
                bw.textContent = 'Write32';
                bw.onclick = doWrite32;

                rowW.appendChild(wval);
                rowW.appendChild(bw);
                pageHex.appendChild(rowW);

                const row2 = document.createElement('div');
                row2.className = 'row';
                row2.appendChild(document.createTextNode('Words:'));

                const words = document.createElement('input');
                words.id = 'memWordsInput';
                words.value = lastMemWordsText || '16';
                words.style.width = '70px';

                const bblk = document.createElement('button');
                bblk.id = 'btnReadBlock';
                bblk.textContent = 'Read block';
                bblk.onclick = doReadBlock;

                const modeLbl = document.createElement('label');
                modeLbl.style.display = 'inline-flex';
                modeLbl.style.alignItems = 'center';
                modeLbl.style.gap = '8px';
                modeLbl.style.color = '#9ca3af';
                modeLbl.style.fontWeight = '700';

                const modeChk = document.createElement('input');
                modeChk.id = 'memUseBlockRead';
                modeChk.type = 'checkbox';
                modeChk.checked = !!lastMemUseBlockRead;
                modeChk.onchange = () => {
                    lastMemUseBlockRead = !!modeChk.checked;
                };
                modeLbl.appendChild(modeChk);
                modeLbl.appendChild(document.createTextNode('Block read'));

                row2.appendChild(words);
                row2.appendChild(bblk);
                row2.appendChild(modeLbl);
                pageHex.appendChild(row2);

                const wbRow = document.createElement('div');
                wbRow.className = 'row';

                const dirtyLabel = document.createElement('span');
                dirtyLabel.style.color = '#9ca3af';
                dirtyLabel.textContent = 'Dirty: 0 words';

                const dirtyUnitName = (w) => {
                    if ((w | 0) === 4) return 'words';
                    if ((w | 0) === 2) return 'halfwords';
                    return 'bytes';
                };

                const updateDirtyUi = () => {
                    const editor = apHexEditors.get(a.ap);
                    if (!editor) {
                        dirtyLabel.textContent = 'Dirty: 0';
                        return;
                    }
                    const width = editor.getEditSizeBytes();
                    editor.setDirtyRegionSize(width);
                    const n = editor.countDirtyRegions(width);
                    dirtyLabel.textContent = `Dirty: ${n} ${dirtyUnitName(width)}`;
                };

                const wbBtn = document.createElement('button');
                wbBtn.textContent = 'Write back';
                wbBtn.onclick = async () => {
                    try {
                        const editor = apHexEditors.get(a.ap);
                        if (!editor) throw new Error('No hex editor instance');
                        if (!editor.isDirty()) {
                            logToConsole(`AP${a.ap} write-back: nothing to write`, 'info');
                            return;
                        }
                        const base = editor.baseAddr >>> 0;
                        const bytes = editor.getData();

                        const width = editor.getEditSizeBytes();
                        editor.setDirtyRegionSize(width);

                        if ((base & (width - 1)) !== 0) {
                            throw new Error(`Write-back base must be ${width * 8}-bit aligned (or pick a smaller width)`);
                        }
                        if ((bytes.length & (width - 1)) !== 0) {
                            throw new Error(`Write-back length must be a multiple of ${width} bytes (or pick a smaller width)`);
                        }

                        const ranges = editor.getDirtyRanges(width);
                        logToConsole(`AP${a.ap} write-back: ${ranges.length} range(s), width=${width * 8}`, 'info');

                        for (const rg of ranges) {
                            const addr = (base + (rg.start >>> 0)) >>> 0;
                            if ((addr & (width - 1)) !== 0) {
                                throw new Error(`Write-back range unaligned for ${width * 8}-bit writes @${u32ToHex(addr)} (pick smaller width)`);
                            }

                            if (width === 4) {
                                const wordsOut = [];
                                const n = (rg.length / 4) | 0;
                                for (let wi = 0; wi < n; wi++) {
                                    const bo = (rg.start + (wi * 4)) | 0;
                                    wordsOut.push(u32FromBytesLE(bytes, bo));
                                }
                                await swd.memWriteBlock32Via(a.ap, addr, wordsOut);
                                logToConsole(`AP${a.ap} write-back: wrote ${n} word(s) @${u32ToHex(addr)}`, 'info');
                            } else if (width === 2) {
                                const halfOut = [];
                                const n = (rg.length / 2) | 0;
                                for (let hi = 0; hi < n; hi++) {
                                    const bo = (rg.start + (hi * 2)) | 0;
                                    const v = (bytes[bo] | (bytes[bo + 1] << 8)) & 0xFFFF;
                                    halfOut.push(v);
                                }
                                await swd.memWriteBlock16Via(a.ap, addr, halfOut);
                                logToConsole(`AP${a.ap} write-back: wrote ${n} halfword(s) @${u32ToHex(addr)}`, 'info');
                            } else {
                                const out = bytes.slice(rg.start, rg.start + rg.length);
                                await swd.memWriteBlock8Via(a.ap, addr, out);
                                logToConsole(`AP${a.ap} write-back: wrote ${out.length} byte(s) @${u32ToHex(addr)}`, 'info');
                            }
                        }

                        editor.clearDirty();
                        updateDirtyUi();
                    } catch (e) {
                        logToConsole(`AP${a.ap} write-back error: ${e.message}`, 'error');
                    }
                };

                wbRow.appendChild(wbBtn);
                wbRow.appendChild(dirtyLabel);
                pageHex.appendChild(wbRow);

                const hexContainer = document.createElement('div');
                pageHex.appendChild(hexContainer);

                let editor = apHexEditors.get(a.ap);
                if (!editor) {
                    editor = new HexEditor({
                        bytesPerRow: 16,
                        onChange: (chg) => {
                            const start = (editor.baseAddr + chg.start) >>> 0;
                            updateDirtyUi();
                            logToConsole(`AP${a.ap} hex edit: ${chg.kind} @${u32ToHex(start)} len=${chg.length}`, 'info');
                        },
                        onModeChange: () => {
                            updateDirtyUi();
                        },
                    });
                    apHexEditors.set(a.ap, editor);
                }
                editor.render(hexContainer);

                /* Update dirty label if we are re-rendering an existing editor. */
                updateDirtyUi();

                /* ============ Debug tab ============ */
                const coreHdr = document.createElement('div');
                coreHdr.style.marginTop = '10px';
                coreHdr.style.color = '#a3e635';
                coreHdr.style.fontWeight = '700';
                coreHdr.textContent = 'Core debug (Cortex-M)';
                pageDebug.appendChild(coreHdr);

                const dbgBanner = document.createElement('div');
                dbgBanner.style.marginTop = '8px';
                dbgBanner.style.color = '#9ca3af';
                dbgBanner.textContent = 'Select the Debugging tab to probe support.';
                pageDebug.appendChild(dbgBanner);

                function renderDebugSupportBanner() {
                    if (debugSupport.state === 'unknown') {
                        dbgBanner.textContent = 'Probing core debug support...';
                        return;
                    }
                    if (debugSupport.state === 'ok') {
                        dbgBanner.textContent = `CPUID: ${u32ToHex(debugSupport.cpuid)} (core debug likely supported)`;
                        return;
                    }
                    dbgBanner.textContent = 'Core debug not supported or access denied.';
                }

                const coreRow = document.createElement('div');
                coreRow.className = 'row';
                pageDebug.appendChild(coreRow);

                const regDefs = [
                    { regsel: 0x00, name: 'R0' }, { regsel: 0x01, name: 'R1' }, { regsel: 0x02, name: 'R2' }, { regsel: 0x03, name: 'R3' },
                    { regsel: 0x04, name: 'R4' }, { regsel: 0x05, name: 'R5' }, { regsel: 0x06, name: 'R6' }, { regsel: 0x07, name: 'R7' },
                    { regsel: 0x08, name: 'R8' }, { regsel: 0x09, name: 'R9' }, { regsel: 0x0A, name: 'R10' }, { regsel: 0x0B, name: 'R11' },
                    { regsel: 0x0C, name: 'R12' }, { regsel: 0x0D, name: 'SP' }, { regsel: 0x0E, name: 'LR' }, { regsel: 0x0F, name: 'PC' },
                    { regsel: 0x10, name: 'xPSR' }, { regsel: 0x11, name: 'MSP' }, { regsel: 0x12, name: 'PSP' }, { regsel: 0x14, name: 'CONTROL' },
                ];

                const regGrid = document.createElement('div');
                regGrid.style.marginTop = '8px';
                regGrid.style.display = 'grid';
                regGrid.style.gridTemplateColumns = 'repeat(4, minmax(0, 1fr))';
                regGrid.style.gap = '6px';

                const regValueEls = new Map();
                let regEditOverlay = null;
                let lastDhcsr = 0;

                const endRegOverlay = () => {
                    if (!regEditOverlay) return;
                    try { regEditOverlay.remove(); } catch (e) { /* ignore */ }
                    regEditOverlay = null;
                };

                const beginRegEdit = async (regsel, targetEl) => {
                    endRegOverlay();

                    if (!swd) {
                        showToast('SWD not initialized', 'error');
                        return;
                    }

                    /* Only allow editing when halted (required by DCRSR semantics). */
                    if ((lastDhcsr & SCS_DHCSR_S_HALT) === 0) {
                        showToast('Reg write requires core halted', 'error');
                        return;
                    }

                    const rect = targetEl.getBoundingClientRect();
                    const overlay = document.createElement('div');
                    overlay.className = 'hex-input-overlay';
                    overlay.style.left = `${Math.max(8, rect.left)}px`;
                    overlay.style.top = `${Math.max(8, rect.top - 2)}px`;

                    const input = document.createElement('input');
                    input.style.width = '140px';
                    input.placeholder = '0x00000000';

                    const currentText = (targetEl.textContent || '').trim();
                    input.value = (currentText && currentText !== '-') ? currentText : '0x00000000';
                    input.maxLength = 10;

                    const finish = async (commit) => {
                        const text = (input.value || '').trim();
                        endRegOverlay();
                        if (!commit) return;
                        let value;
                        try {
                            value = parseHexOrDec(text) >>> 0;
                        } catch (e) {
                            showToast('Bad value', 'error');
                            return;
                        }
                        try {
                            await swd.coreRegWriteVia(a.ap, regsel, value);
                            await refreshCoreRegs();
                        } catch (e) {
                            showToast(`Reg write failed: ${e.message}`, 'error');
                        }
                    };

                    input.addEventListener('keydown', (ev) => {
                        if (ev.key === 'Enter') {
                            ev.preventDefault();
                            finish(true);
                        } else if (ev.key === 'Escape') {
                            ev.preventDefault();
                            finish(false);
                        }
                    });
                    input.addEventListener('blur', () => {
                        finish(true);
                    });

                    overlay.appendChild(input);
                    document.body.appendChild(overlay);
                    regEditOverlay = overlay;
                    input.focus();
                    input.select();
                };

                /* Click elsewhere closes the overlay. */
                try {
                    pageDebug.addEventListener('click', (ev) => {
                        if (!regEditOverlay) return;
                        const t = ev && ev.target ? ev.target : null;
                        if (t && regEditOverlay.contains(t)) return;
                        endRegOverlay();
                    });
                } catch (e) {
                    /* ignore */
                }
                for (const r of regDefs) {
                    const cell = document.createElement('div');
                    cell.style.border = '1px solid #374151';
                    cell.style.borderRadius = '6px';
                    cell.style.background = '#0b1220';
                    cell.style.padding = '8px 10px';

                    const label = document.createElement('div');
                    label.style.color = '#9ca3af';
                    label.style.fontSize = '12px';
                    label.style.fontWeight = '700';
                    label.textContent = r.name;

                    const value = document.createElement('div');
                    value.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
                    value.style.fontSize = '13px';
                    value.style.color = '#e5e7eb';
                    value.textContent = '-';
                    value.style.cursor = 'text';
                    value.title = 'Double-click to edit (core must be halted)';

                    value.ondblclick = async (ev) => {
                        try {
                            ev.preventDefault();
                            ev.stopPropagation();
                        } catch (e) { /* ignore */ }
                        await beginRegEdit(r.regsel, value);
                    };

                    cell.appendChild(label);
                    cell.appendChild(value);
                    regGrid.appendChild(cell);
                    regValueEls.set(r.regsel, value);
                }

                let regReadToken = 0;
                let lastPc = null;
                const setAllRegs = (text) => {
                    for (const el of regValueEls.values()) el.textContent = text;
                };

                const disasmBox = document.createElement('div');
                disasmBox.className = 'disasm-box';
                disasmBox.style.display = 'none';

                const disasmHdr = document.createElement('div');
                disasmHdr.className = 'disasm-header';
                disasmHdr.textContent = 'Disassembly @ PC';

                const disasmView = document.createElement('div');
                disasmView.className = 'disasm-view';
                disasmView.textContent = '(click Disasm @PC)';

                disasmBox.appendChild(disasmHdr);
                disasmBox.appendChild(disasmView);

                async function refreshDisasmFromPc() {
                    disasmBox.style.display = 'block';
                    if (lastPc === null || lastPc === undefined) {
                        disasmView.textContent = '(PC unknown - refresh regs while halted)';
                        return;
                    }

                    const pcRaw = (lastPc >>> 0);
                    const pc = (pcRaw & 1) ? (pcRaw & ~1) : pcRaw;

                    disasmView.textContent = 'Disassembling...';
                    try {
                        await ensureCapstoneReady();

                        const isZeroOkDisasmError = (err) => {
                            const msg = (err && err.message) ? String(err.message) : String(err);
                            return msg.includes('cs_disasm') && msg.includes('code 0') && (msg.includes('CS_ERR_OK') || msg.includes('OK (CS_ERR_OK)'));
                        };

                        /* Read a window around PC. Thumb is variable-length; over-read a bit. */
                        const preBytes = 64;
                        const totalBytes = 192;
                        const start = (pc < preBytes) ? 0 : ((pc - preBytes) >>> 0);
                        const startAligned = (start & ~3) >>> 0;
                        const words = Math.max(1, Math.ceil(totalBytes / 4));

                        const dataWords = await swd.memReadBlock32Via(a.ap, startAligned, words);
                        const buf = new Uint8Array(words * 4);
                        for (let i = 0; i < dataWords.length; i++) {
                            const v = dataWords[i] >>> 0;
                            buf[i * 4 + 0] = v & 0xFF;
                            buf[i * 4 + 1] = (v >>> 8) & 0xFF;
                            buf[i * 4 + 2] = (v >>> 16) & 0xFF;
                            buf[i * 4 + 3] = (v >>> 24) & 0xFF;
                        }

                        if (cs.ARCH_ARM === undefined || cs.MODE_THUMB === undefined) {
                            throw new Error('Capstone ARM/THUMB constants missing');
                        }

                        let mode = cs.MODE_THUMB;
                        if (cs.MODE_MCLASS !== undefined) mode |= cs.MODE_MCLASS;
                        if (cs.MODE_LITTLE_ENDIAN !== undefined) mode |= cs.MODE_LITTLE_ENDIAN;

                        const d = new cs.Capstone(cs.ARCH_ARM, mode);

                        let ins = null;
                        let disErr = null;
                        for (const input of [buf, Array.from(buf)]) {
                            try {
                                ins = d.disasm(input, startAligned >>> 0);
                                disErr = null;
                                break;
                            } catch (e) {
                                if (isZeroOkDisasmError(e)) {
                                    ins = [];
                                    disErr = null;
                                    break;
                                }
                                disErr = e;
                            }
                        }
                        try { d.close(); } catch (e) { /* ignore */ }

                        if (disErr) throw disErr;

                        if (!ins) ins = [];

                        if (!ins.length) {
                            disasmView.textContent = '(no instructions decoded)';
                            return;
                        }

                        let active = 0;
                        for (let i = 0; i < ins.length; i++) {
                            const a0 = (ins[i].address >>> 0);
                            const a1 = (i + 1 < ins.length) ? (ins[i + 1].address >>> 0) : ((a0 + 4) >>> 0);
                            if (pc === a0) { active = i; break; }
                            if (pc > a0 && pc < a1) { active = i; break; }
                            if (pc < a0) { active = Math.max(0, i - 1); break; }
                            active = i;
                        }

                        const startIdx = Math.max(0, active - 8);
                        const endIdx = Math.min(ins.length, active + 9);

                        disasmView.innerHTML = '';
                        for (let i = startIdx; i < endIdx; i++) {
                            const it = ins[i];
                            const line = document.createElement('span');
                            line.className = 'disasm-line' + (i === active ? ' active' : '');
                            const addr = u32ToHex(it.address >>> 0);
                            const mnem = (it.mnemonic || '').toString();
                            const ops = (it.op_str || '').toString();
                            line.textContent = `${addr}:\t${mnem}\t${ops}`;
                            disasmView.appendChild(line);
                        }
                    } catch (e) {
                        disasmView.textContent = `Disasm failed: ${e.message || e}`;
                    }
                }

                async function refreshCoreRegs() {
                    const token = ++regReadToken;
                    setAllRegs('-');
                    lastPc = null;
                    lastDhcsr = 0;

                    let dhcsr = 0;
                    try {
                        dhcsr = await swd.memRead32Via(a.ap, SCS_DHCSR);
                    } catch (e) {
                        return;
                    }

                    lastDhcsr = dhcsr >>> 0;

                    if ((dhcsr & SCS_DHCSR_S_HALT) === 0) {
                        /* Reading core regs via DCRSR/DCRDR requires the core to be halted.
                         * Show '-' when forbidden.
                         */
                        return;
                    }

                    for (const r of regDefs) {
                        if (token !== regReadToken) return;
                        const el = regValueEls.get(r.regsel);
                        if (!el) continue;
                        try {
                            const v = await swd.coreRegReadVia(a.ap, r.regsel);
                            el.textContent = u32ToHex(v);
                            if (r.regsel === 0x0F) lastPc = v >>> 0;
                        } catch (e) {
                            el.textContent = '-';
                        }
                    }

                    /* Best-effort auto-refresh disassembly when regs are available. */
                    try {
                        await refreshDisasmFromPc();
                    } catch (e) {
                        /* ignore */
                    }
                }

                const btnCpuid = document.createElement('button');
                btnCpuid.textContent = 'CPUID';
                btnCpuid.onclick = async () => {
                    try {
                        const v = await swd.coreCpuidVia(a.ap);
                        logToConsole(`AP${a.ap} CPUID @${u32ToHex(SCS_CPUID)} => ${u32ToHex(v)}`, 'info');
                    } catch (e) {
                        logToConsole(`AP${a.ap} CPUID error: ${e.message}`, 'error');
                    }
                };

                const btnHalt = document.createElement('button');
                btnHalt.textContent = 'Halt';
                btnHalt.onclick = async () => {
                    try {
                        const r = await swd.coreHaltVia(a.ap);
                        logToConsole(`AP${a.ap} core halt: halted=${r.halted ? 1 : 0} DHCSR=${u32ToHex(r.dhcsr)}`, r.halted ? 'info' : 'error');
                        await refreshCoreRegs();
                    } catch (e) {
                        logToConsole(`AP${a.ap} core halt error: ${e.message}`, 'error');
                        setAllRegs('-');
                    }
                };

                const btnCont = document.createElement('button');
                btnCont.textContent = 'Continue';
                btnCont.onclick = async () => {
                    try {
                        const r = await swd.coreContinueVia(a.ap);
                        if (!r.continued) {
                            logToConsole(`AP${a.ap} core continue: ${r.reason || 'failed'} DHCSR=${u32ToHex(r.dhcsr)}`, 'error');
                        } else {
                            logToConsole(`AP${a.ap} core continued: DHCSR=${u32ToHex(r.dhcsr)}`, 'info');
                        }
                    } catch (e) {
                        logToConsole(`AP${a.ap} core continue error: ${e.message}`, 'error');
                    }
                };

                const btnStep = document.createElement('button');
                btnStep.textContent = 'Step';
                btnStep.onclick = async () => {
                    try {
                        const r = await swd.coreStepVia(a.ap);
                        if (!r.stepped) {
                            logToConsole(`AP${a.ap} core step: ${r.reason || 'failed'} DHCSR=${u32ToHex(r.dhcsr)}`, 'error');
                        } else {
                            logToConsole(`AP${a.ap} core stepped: DHCSR=${u32ToHex(r.dhcsr)}`, 'info');
                        }
                        await refreshCoreRegs();
                    } catch (e) {
                        logToConsole(`AP${a.ap} core step error: ${e.message}`, 'error');
                        setAllRegs('-');
                    }
                };

                const btnRegs = document.createElement('button');
                btnRegs.textContent = 'Refresh regs';
                btnRegs.onclick = async () => {
                    try {
                        await refreshCoreRegs();
                    } catch (e) {
                        setAllRegs('-');
                    }
                };

                const btnDisasm = document.createElement('button');
                btnDisasm.textContent = 'Disasm @PC';
                btnDisasm.onclick = async () => {
                    try {
                        if (lastPc === null || lastPc === undefined) {
                            await refreshCoreRegs();
                        } else {
                            await refreshDisasmFromPc();
                        }
                    } catch (e) {
                        disasmBox.style.display = 'block';
                        disasmView.textContent = `Disasm failed: ${e.message || e}`;
                    }
                };

                coreRow.appendChild(btnCpuid);
                coreRow.appendChild(btnHalt);
                coreRow.appendChild(btnCont);
                coreRow.appendChild(btnStep);
                coreRow.appendChild(btnRegs);
                coreRow.appendChild(btnDisasm);
                pageDebug.appendChild(regGrid);
                pageDebug.appendChild(disasmBox);

                /* ============ CoreSight tab ============ */
                const csHdr = document.createElement('div');
                csHdr.style.marginTop = '10px';
                csHdr.style.color = '#a3e635';
                csHdr.style.fontWeight = '700';
                csHdr.textContent = 'CoreSight ROM table';
                pageCoresight.appendChild(csHdr);

                const csRow = document.createElement('div');
                csRow.className = 'row';

                const csBaseInput = document.createElement('input');
                csBaseInput.value = (() => {
                    if (a.base === null || a.base === undefined) return '0xE00FF000';
                    const base = a.base >>> 0;
                    const present = (base & 1) !== 0;
                    const addr = (base & 0xFFFFF000) >>> 0;
                    return present ? u32ToHex(addr) : '0xE00FF000';
                })();
                csBaseInput.style.width = '140px';

                const csPath = document.createElement('span');
                csPath.style.color = '#9ca3af';
                csPath.textContent = '';

                const csOut = document.createElement('div');
                csOut.style.marginTop = '8px';
                csOut.style.padding = '8px';
                csOut.style.border = '1px solid #374151';
                csOut.style.borderRadius = '6px';
                csOut.style.background = '#0b1220';
                csOut.textContent = '(not scanned)';

                let csTree = null;
                const csKeyOf = (base) => `${a.ap}:${((base >>> 0) & 0xFFFFF000) >>> 0}`;

                async function csBuildTreeOnce(rootBase) {
                    const base0 = ((rootBase >>> 0) & 0xFFFFF000) >>> 0;
                    const key = csKeyOf(base0);
                    const cached = coresightTreeCache.get(key);
                    if (cached) return cached;

                    const maxDepth = 7;
                    const maxNodes = 256;
                    const visited = new Set();

                    async function buildAt(baseAddr, depth) {
                        const base = ((baseAddr >>> 0) & 0xFFFFF000) >>> 0;
                        const node = {
                            base,
                            depth,
                            cls: null,
                            pidr: null,
                            part: null,
                            devarch: null,
                            devtype: null,
                            isRomTable: false,
                            children: [],
                            error: null,
                            expanded: (depth === 0)
                        };

                        if (visited.has(base)) {
                            node.error = 'loop';
                            return node;
                        }
                        if (visited.size >= maxNodes) {
                            node.error = 'node limit';
                            return node;
                        }
                        visited.add(base);

                        if (depth > maxDepth) {
                            node.error = 'depth limit';
                            return node;
                        }

                        try {
                            const cls = await swd.adiGetClassVia(a.ap, base);
                            node.cls = cls;
                            if (cls === null) {
                                node.error = 'bad CIDR';
                                return node;
                            }

                            const pidr = await swd.adiGetPidrVia(a.ap, base);
                            node.pidr = pidr;
                            node.part = adiPartNumLookup(pidr.designer, pidr.part);

                            if (cls === CIDR_CLASS_CORESIGHT) {
                                try {
                                    node.devarch = await swd.memRead32Via(a.ap, (base + CS_DEVARCH) >>> 0);
                                    node.devtype = await swd.memRead32Via(a.ap, (base + CS_DEVTYPE) >>> 0);
                                } catch (e) {
                                    /* ignore */
                                }
                            }

                            if (cls !== CIDR_CLASS_ROMTABLE) {
                                return node;
                            }

                            node.isRomTable = true;
                            const count = await swd.adiRomtableEntryCountVia(a.ap, base);
                            for (let i = 0; i < count; i++) {
                                const childBase = await swd.adiRomtableGetVia(a.ap, base, i);
                                const child = await buildAt(childBase, depth + 1);
                                child.index = i;
                                node.children.push(child);
                            }
                        } catch (e) {
                            node.error = e.message;
                        }

                        return node;
                    }

                    const tree = await buildAt(base0, 0);
                    coresightTreeCache.set(key, tree);
                    return tree;
                }

                function csRenderTree() {
                    csOut.innerHTML = '';
                    if (!csTree) {
                        csOut.textContent = '(not scanned)';
                        return;
                    }

                    const header = document.createElement('div');
                    header.style.color = '#9ca3af';
                    header.style.marginBottom = '8px';
                    header.textContent = 'Click nodes to expand/collapse (cached; no re-scan on click).';
                    csOut.appendChild(header);

                    const list = document.createElement('div');
                    list.style.display = 'flex';
                    list.style.flexDirection = 'column';
                    list.style.gap = '4px';

                    const renderNode = (node, ancestorsExpanded) => {
                        const visible = ancestorsExpanded;
                        const row = document.createElement('div');
                        row.style.display = visible ? 'flex' : 'none';
                        row.style.alignItems = 'center';
                        row.style.gap = '8px';
                        row.style.padding = '6px 8px';
                        row.style.border = '1px solid #1f2937';
                        row.style.borderRadius = '6px';
                        row.style.background = '#0f172a';
                        row.style.cursor = (node.children && node.children.length) ? 'pointer' : 'default';
                        row.style.paddingLeft = `${8 + (node.depth * 14)}px`;

                        const twist = document.createElement('div');
                        twist.style.width = '16px';
                        twist.style.color = '#9ca3af';
                        const hasKids = (node.children && node.children.length);
                        twist.textContent = hasKids ? (node.expanded ? '' : '') : '';

                        const title = document.createElement('div');
                        title.style.flex = '1';
                        title.style.whiteSpace = 'nowrap';
                        title.style.overflow = 'hidden';
                        title.style.textOverflow = 'ellipsis';

                        const clsTxt = (node.cls === null) ? '?' : `0x${node.cls.toString(16)}`;
                        const clsName = (node.cls === CIDR_CLASS_ROMTABLE) ? 'ROM' : (node.cls === CIDR_CLASS_CORESIGHT ? 'CS' : '');
                        const pn = node.part ? node.part.type : 'Unrecognized';
                        const err = node.error ? `  (${node.error})` : '';
                        const idx = (node.index !== undefined) ? `#${node.index} ` : '';
                        title.textContent = `${idx}${u32ToHex(node.base)}  class=${clsTxt}${clsName ? ' ' + clsName : ''}  ${pn}${err}`;

                        row.appendChild(twist);
                        row.appendChild(title);

                        if (hasKids) {
                            row.onclick = () => {
                                node.expanded = !node.expanded;
                                csRenderTree();
                            };
                        }

                        list.appendChild(row);

                        const kidsVisible = visible && (!!node.expanded);
                        if (hasKids) {
                            for (const ch of node.children) {
                                renderNode(ch, kidsVisible);
                            }
                        }
                    };

                    renderNode(csTree, true);
                    csOut.appendChild(list);
                }

                const csBtnScan = document.createElement('button');
                csBtnScan.textContent = 'Scan';
                csBtnScan.onclick = async () => {
                    try {
                        const base = parseHexOrDec(csBaseInput.value);
                        /* Clear any old view and force a fresh scan for this base. */
                        csTree = null;
                        coresightTreeCache.delete(csKeyOf(base));
                        csOut.textContent = 'Scanning...';
                        csTree = await csBuildTreeOnce(base);
                        csRenderTree();
                    } catch (e) {
                        logToConsole(`AP${a.ap} CoreSight scan error: ${e.message}`, 'error');
                    }
                };

                csRow.appendChild(document.createTextNode('Base:'));
                csRow.appendChild(csBaseInput);
                csRow.appendChild(csBtnScan);
                pageCoresight.appendChild(csRow);
                pageCoresight.appendChild(csOut);

                /* Show cached tree if present for current base value. */
                try {
                    const b0 = parseHexOrDec(csBaseInput.value);
                    const cached = coresightTreeCache.get(csKeyOf(b0));
                    if (cached) {
                        csTree = cached;
                        csRenderTree();
                    }
                } catch (e) {
                    /* ignore */
                }
            } else {
                const memHint = document.createElement('div');
                memHint.style.marginTop = '8px';
                memHint.style.color = '#9ca3af';
                memHint.textContent = 'Non MEM-AP: memory access / CoreSight / debugging tabs are unavailable.';
                pageHex.appendChild(memHint.cloneNode(true));
                pageCoresight.appendChild(memHint.cloneNode(true));
                pageDebug.appendChild(memHint.cloneNode(true));
            }

            /* Initial render */
            selectSubTab(selected);
            refreshApInfo();
        }

        /* ============= Core UI and Connection Functions ============= */

        function logToConsole(message, level = 'info') {
            const consoleEl = document.getElementById('consoleDisplay');
            if (!consoleEl) return;

            const now = new Date().toLocaleTimeString();
            const levelTag = level ? `[${level.toUpperCase()}]` : '';
            const line = `${now} ${levelTag} ${message}`;

            consoleLineBuffer.push(line);
            if (consoleLineBuffer.length > MAX_CONSOLE_LINES) {
                consoleLineBuffer.splice(0, consoleLineBuffer.length - MAX_CONSOLE_LINES);
            }

            consoleEl.textContent = consoleLineBuffer.join('\n') + '\n';
            consoleEl.scrollTop = consoleEl.scrollHeight;
        }

        function clearConsole() {
            const consoleEl = document.getElementById('consoleDisplay');
            consoleLineBuffer.length = 0;
            if (consoleEl) consoleEl.textContent = '';
        }

        function getTadaaAudio() {
            if (tadaaAudio) return tadaaAudio;

            const embeddedB64 = (window.TADAA_MP3_B64 !== undefined) ? window.TADAA_MP3_B64 : null;
            if (embeddedB64 && typeof embeddedB64 === 'string' && embeddedB64.length) {
                if (!tadaaAudioUrl) {
                    const bin = atob(embeddedB64);
                    const u8 = new Uint8Array(bin.length);
                    for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i) & 0xFF;
                    const blob = new Blob([u8], { type: 'audio/mpeg' });
                    tadaaAudioUrl = URL.createObjectURL(blob);
                }
                const a = new Audio(tadaaAudioUrl);
                a.preload = 'auto';
                tadaaAudio = a;
                return a;
            }

            const a = new Audio('tadaa.mp3');
            a.preload = 'auto';
            tadaaAudio = a;
            return a;
        }

        function primeTadaaAudio() {
            if (tadaaAudioPrimed) return;
            tadaaAudioPrimed = true;
            try {
                const a = getTadaaAudio();
                a.load();
                const oldVolume = a.volume;
                a.volume = 0;
                const p = a.play();
                if (p && typeof p.then === 'function') {
                    p.then(() => {
                        a.pause();
                        a.currentTime = 0;
                        a.volume = oldVolume;
                    }).catch(() => {
                        a.pause();
                        a.currentTime = 0;
                        a.volume = oldVolume;
                    });
                } else {
                    a.pause();
                    a.currentTime = 0;
                    a.volume = oldVolume;
                }
            } catch (e) {
                /* ignore */
            }
        }

        function playTadaa() {
            try {
                const a = getTadaaAudio();
                a.currentTime = 0;
                const p = a.play();
                if (p && typeof p.catch === 'function') {
                    p.catch(() => { /* ignore autoplay blocking */ });
                }
            } catch (e) {
                /* ignore */
            }
        }

        async function connectDevice() {
            try {
                const btn = document.getElementById('connectBtn');
                const discBtn = document.getElementById('disconnectBtn');
                const statusEl = document.getElementById('statusIndicator');
                const devUi = document.getElementById('deviceInteraction');

                btn.disabled = true;
                logToConsole('Connecting...', 'info');

                const esp = initializeEspSerial();
                if (await esp.connect()) {
                    logToConsole('Connected successfully', 'info');
                    statusEl.textContent = 'Connected';
                    statusEl.classList.add('connected');
                    btn.disabled = true;
                    discBtn.disabled = false;

                    if (devUi) devUi.style.display = '';
                    
                    /* Wire up SWD Test button */
                    const testBtn = document.getElementById('btnRunSWDTest');
                    if (testBtn) testBtn.onclick = runSWDTest;

                    const scanBtn = document.getElementById('btnScanAps');
                    if (scanBtn) scanBtn.onclick = scanAps;

                    const dpBtn = document.getElementById('btnDpDebug');
                    if (dpBtn) dpBtn.onclick = dpDebug;

                    swd = new Swd(espSerial, logToConsole);
                } else {
                    logToConsole('Connection failed', 'error');
                    btn.disabled = false;
                    if (devUi) devUi.style.display = 'none';
                }
            } catch (err) {
                logToConsole(`Connection error: ${err.message}`, 'error');
                document.getElementById('connectBtn').disabled = false;
                const devUi = document.getElementById('deviceInteraction');
                if (devUi) devUi.style.display = 'none';
            }
        }

        async function disconnectDevice() {
            try {
                const btn = document.getElementById('connectBtn');
                const discBtn = document.getElementById('disconnectBtn');
                const statusEl = document.getElementById('statusIndicator');
                const devUi = document.getElementById('deviceInteraction');

                if (espSerial) {
                    await espSerial.disconnect();
                }

                /* Stop any active cyclic detection loop. */
                detectLoopActive = false;
                detectLoopToken++;

                swd = null;

                const scanBtn = document.getElementById('btnScanAps');
                const dpBtn = document.getElementById('btnDpDebug');
                if (scanBtn) scanBtn.disabled = true;
                if (dpBtn) dpBtn.disabled = true;

                const pinsEl = document.getElementById('detectedPins');
                const idsEl = document.getElementById('detectedIds');
                const apTabsEl = document.getElementById('apTabs');
                const apPanelEl = document.getElementById('apPanel');
                if (pinsEl) pinsEl.textContent = '-';
                if (idsEl) idsEl.textContent = '-';
                if (apTabsEl) apTabsEl.innerHTML = '';
                if (apPanelEl) apPanelEl.textContent = '(not scanned)';
                
                scannedAps = [];
                activeAp = null;
                apHexEditors.clear();

                logToConsole('Disconnected', 'info');
                statusEl.textContent = 'Disconnected';
                statusEl.classList.remove('connected');
                btn.disabled = false;
                discBtn.disabled = true;

                if (devUi) devUi.style.display = 'none';
            } catch (err) {
                logToConsole(`Disconnect error: ${err.message}`, 'error');
            }
        }

        function initializeGpioCheckboxes() {
            const container = document.getElementById('ioGpioCheckboxes');
            
            /* ESP32-C3 available GPIO pins: 0-10, 20-21 */
            const gpios = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 21];
            
            for (const gpio of gpios) {
                const label = document.createElement('label');
                label.style.display = 'flex';
                label.style.alignItems = 'center';
                label.style.gap = '6px';
                label.style.cursor = 'pointer';
                label.style.color = '#e5e7eb';
                label.style.fontSize = '13px';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = gpio;
                checkbox.style.cursor = 'pointer';
                checkbox.checked = (gpio >= 20);
                
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(`GPIO${gpio}`));
                container.appendChild(label);
            }
        }

        window.onload = () => {
            logToConsole('SWD Console ready', 'info');
            logToConsole('Click Connect to begin', 'info');

            const devUi = document.getElementById('deviceInteraction');
            if (devUi) devUi.style.display = 'none';
            
            /* Initialize GPIO checkboxes */
            initializeGpioCheckboxes();
            
            /* Wire up connect/disconnect buttons */
            const connectBtn = document.getElementById('connectBtn');
            if (connectBtn) connectBtn.onclick = connectDevice;

            const disconnectBtn = document.getElementById('disconnectBtn');
            if (disconnectBtn) disconnectBtn.onclick = disconnectDevice;

            const clearBtn = document.getElementById('clearBtn');
            if (clearBtn) clearBtn.onclick = clearConsole;
        };
    </script>
</body>

</html>